[ { "title": "分布式数据库事务-Percolator", "url": "/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1-Percolator/", "categories": "计算机, DB", "tags": "", "date": "2023-02-03 14:07:43 +0800", "snippet": "PDF" }, { "title": "DBMS与mmap", "url": "/posts/mmap/", "categories": "计算机, DB", "tags": "", "date": "2022-12-30 16:03:15 +0800", "snippet": "mmap 文件 I/O 是操作系统提供的一项功能，它将二级存储中的文件内容映射到程序的地址空间。然后，程序通过指针访问页面，就像文件完全位于内存中一样。操作系统只在程序引用时透明地加载页面，并在内存填满时自动驱逐页面。mmap 的易用性几十年来一直吸引着数据库管理系统（DBMS）的开发者，作为实现 buffer pool 的一个可行的替代方案。然而，mmap 存在严重的正确性和性能问题，这些问题并不明显。这些问题使得在现代 DBMS 中正确有效地使用 mmap 很困难，甚至不可能。事实上，几个流行的 DBMS 最初使用 mmap 来支持大于内存的数据库，但很快就遇到了这些隐藏的危险，迫使他们在付出巨大的工程成本后转而自己管理文件 I/O。这样一来，mmap 和 DBMS 就像咖啡和辛辣的食物：一个不幸的组合，事后才发现。由于开发者不断尝试在新的 DBMS 中使用 mmap，我们写这篇文章是为了给其他人一个警告，mmap 并不是传统 buffer pool 的合适替代品。我们详细讨论了 mmap 的主要缺点，我们的实验分析证明了明显的性能限制。基于这些发现，我们总结了 DBMS 开发者何时可以考虑使用 mmap 进行文件 I/O 的处方。基于磁盘的 DBMS 的一个重要特征是它们能够支持大于可用物理内存的数据库。这种功能允许用户查询数据库，就像它完全驻留在内存中一样，即使它不能一下子装下。DBMS 通过按要求从二级存储（如 HDD、SSD）中读取数据页到内存中来实现这种幻觉。如果没有足够的内存来容纳新的页面，DBMS 将驱逐一个不再需要的现有页面，以腾出空间。传统上，DBMS 在 buffer pool 中实现二级存储和内存之间的页面移动， buffer pool 使用读取和写入等系统调用与二级存储交互。 这些文件 I/O 机制将数据复制到用户空间中的缓冲区或从中复制数据，DBMS 保持对它传输页面的方式和时间的完全控制。或者，DBMS 可以将数据移动的责任交给操作系统，操作系统维护自己的文件映射和 page cache 。 POSIX mmap 系统调用将二级存储上的文件映射到调用者（即 DBMS）的虚拟地址空间，然后操作系统将在 DBMS 访问它们时延迟加载页面。 对于 DBMS，数据库似乎完全驻留在内存中，但操作系统在后台处理所有必要的分页，而不是 DBMS 的 buffer pool。从表面上看，mmap 似乎是一个在 DBMS 中管理文件 I/O 的有吸引力的实现选项。 最显着的好处是易于使用和低工程成本。 DBMS 不再需要跟踪哪些页面在内存中，也不需要跟踪访问页面的频率或哪些页面是脏的。 相反，DBMS 可以简单地通过指针访问磁盘驻留数据，就像访问内存中的数据一样，同时将所有低级页面管理留给操作系统。 如果可用内存已满，操作系统将通过透明地从 page cache 中逐出（理想情况下不需要的）页面来为新页面释放空间。从性能的角度来看，mmap 的开销也应该比传统的 buffer pool 低得多。 具体来说，mmap 不会产生显式系统调用（即读/写）的成本，并且避免冗余复制到用户空间中的缓冲区，因为 DBMS 可以直接从操作系统 page cache 访问页面。自 1980 年代初以来，这些假定的好处已经诱使 DBMS 开发人员放弃实施 buffer pool，转而依赖操作系统来管理文件 I/O [36]。 事实上，几个著名的 DBMS（请参阅第 2.3 节）的开发人员已经走上了这条道路，一些人甚至将 mmap 吹捧为实现良好性能的关键因素 [20]。不幸的是，mmap 有一个隐藏的阴暗面，它有许多肮脏的问题，这使得它不适合 DBMS 中的文件 I/O。 正如我们在本文中所描述的，这些问题涉及数据安全和系统性能问题。 我们认为克服它们所需的工程步骤否定了使用 mmap 所声称的简单性。 出于这些原因，我们认为 mmap 增加了太多的复杂性而没有相应的性能优势，并强烈敦促 DBMS 开发人员避免使用 mmap 作为传统 buffer pool 的替代品。本文的其余部分安排如下。 我们从 mmap 的简短背景开始（第 2 节），然后讨论其主要问题（第 3 节）和我们的实验分析（第 4 节）。 然后，我们将讨论相关工作（第 5 节），并总结我们的指南，以便您考虑在 DBMS 中使用 mmap（第 6 节）。本节提供有关 mmap 的相关背景。 我们从内存映射文件 I/O 和 POSIX mmap API 的高级概述开始。 然后，我们讨论基于 mmap 的系统的实际实现。图 1 显示了如何使用 mmap 访问文件（“cidr.db”）的分步概述。 ① 程序调用 mmap 并接收指向内存映射文件内容的指针。 ② 操作系统保留部分程序的虚拟地址空间，但不加载文件的任何部分。 ③ 程序使用指针访问文件内容。 ④ 操作系统尝试检索页面。 ⑤ 由于指定的虚拟地址不存在有效映射，操作系统触发缺页异常以将文件的引用部分从辅助存储加载到物理内存页面。 ⑥ 操作系统在页表中添加一个条目，将虚拟地址映射到新的物理地址。 ⑦ 启动 CPU 内核还将此条目缓存在其本地 页表缓存 (TLB) 中，以加速未来的访问。当程序访问其他页面时，操作系统会将它们加载到内存中，如果 page cache 已满，则根据需要逐出页面。 逐出页面时，操作系统还会从页表和每个 CPU 内核的 TLB 中删除它们的映射。 刷新启动核心的本地 TLB 很简单，但操作系统必须确保远程核心的 TLB 中没有过时的条目。 由于当前的 CPU 不为远程 TLB 提供一致性，因此操作系统必须发出昂贵的处理器间中断来刷新它们，这称为 TLB 击落 [11]。 正如我们的实验所示（第 4 节），TLB 击落会对性能产生重大影响。我们现在回顾内存映射文件 I/O 的最重要的 POSIX 系统调用，并描述 DBMS 如何使用它们代替传统的 buffer pool。mmap：如前所述，此调用导致操作系统将文件映射到 DBMS 的虚拟地址空间。 然后 DBMS 可以使用普通的内存操作读取或写入文件内容。 操作系统将页面缓存在内存中，并在使用 MAP_SHARED 标志时（最终）将任何更改写回基础文件。 或者，MAP_PRIVATE 标志将创建一个只能由调用者访问的写时复制映射（即，更改不会持久保存到支持文件）。madvise：此调用允许 DBMS 向操作系统提供有关预期数据访问模式的提示，无论是在整个文件的粒度还是针对特定页面范围。 我们关注三个常见提示：MADV_NORMAL、MADV_RANDOM 和 MADV_SEQUENTIAL。 当在默认 MADV_NORMAL 提示的 Linux 中发生缺页异常时，操作系统将获取访问的页面，以及接下来的 16 页和之前的 15 页。 对于 4 KB 的页面，MADV_NORMAL 会导致操作系统从辅助存储读取 128 KB，即使调用者只请求了一个页面。 根据工作负载，这种预取可能有助于或损害 DBMS 的性能。 例如，只读取必要页面的 MADV_RANDOM 模式是大于内存的 OLTP 工作负载的更好选择，而 MADV_SEQUENTIAL 更适合顺序扫描的 OLAP 工作负载。mlock：此调用允许 DBMS 将页面固定在内存中，确保操作系统永远不会驱逐它们。 但是，根据 POSIX 标准（和 Linux 的实现），允许操作系统随时将脏页刷新到备份文件，即使该页已固定。 因此，DBMS无法使用mlock来确保脏页永远不会写入二级存储，这对事务安全有严重影响msync：最后，这个调用显式地将指定的内存范围刷新到辅助存储。 如果没有 msync，DBMS 就没有其他方法来保证更新持久保存到备份文件中。操作系统管理的 DBMS buffer pool 的吸引力已经存在了几十年 [36]，QuickStore [40] 和 Dalí [22] 是 1990 年代基于 mmap 的系统的早期示例。 今天，一些 DBMS 继续使用 mmap 进行文件 I/O，如表 1 所示。例如，MonetDB 将各个列存储为内存映射文件 [12、21]，SQLite 提供了使用 mmap 的选项，而不是默认的 read/write 系统调用[7]。 LMDB 完全依赖 mmap，开发人员甚至将其视为影响系统性能的主要因素 [20]。 其他具有基于 mmap 的存储引擎的系统包括 QuestDB [34] 和 RavenDB [4]。尽管有这些明显的成功案例，但许多其他 DBMS 已经尝试（但都失败了）用基于 mmap 的文件 I/O 替换传统的 buffer pool。 在下文中，我们将讲述一些警示故事，以说明在您的 DBMS 中使用 mmap 会如何出现可怕的错误。MongoDB 可以说是最著名的使用 mmap 进行文件 I/O 的 DBMS。 我们从开发人员那里了解到，他们选择将原始存储引擎 (MMAPv1) 基于 mmap 作为早期启动的权宜之计。 然而，该设计有许多缺点，包括过于复杂的复制方案以确保正确性以及无法对二级存储上的数据执行任何压缩。 对于后者，由于操作系统管理文件映射，内存中的数据布局需要与辅助存储上的物理表示相匹配，从而导致空间浪费和 I/O 吞吐量降低。 随着 2015 年 WiredTiger 作为默认存储引擎的引入，MongoDB 弃用了 MMAPv1，然后在 2019 年将其完全删除 [3]。 不过，在 2020 年，MongoDB 重新引入了 mmap 作为 WiredTiger 中的一个选项，但它以有限的方式使用，以避免用户空间和操作系统之间的 boundary-crossing penalties [17]。InfluxDB 是一个时间序列 DBMS，在早期版本 [8] 中使用 mmap 进行文件 I/O。 然而，开发人员在观察到当数据库的大小超过几 GB 时写入 I/O 峰值后替换了 mmap，这可能是由于与页面驱逐相关的开销（第 3.4 节）。 在容器化环境或没有直连存储的机器上运行时（例如，云部署），他们还面临其他问题，这进一步排除了在他们的新 IOx 存储引擎 [1] 中使用 mmap 的可能性。在简单的顺序扫描查询 [32] 上遇到性能不佳后，SingleStore 删除了基于 mmap 的文件 I/O。 DBMS 对 mmap 的调用每次查询需要 10-20 毫秒，这几乎占了整个查询运行时间的一半。 经过进一步调查，开发人员将问题的根源确定为对共享 mmap 写锁的争用。 通过切换到 read 系统调用，查询变得完全受 CPU 限制。许多其他系统在开发初期就排除了 mmap。 例如，Facebook 创建 RocksDB 作为 Google 的 LevelDB 的一个分支，部分原因是后者使用 mmap [5] 导致读取性能瓶颈。 TileDB 发现 mmap 比 SSD 的 read 系统调用更昂贵 [27]，我们也在我们的实验分析（第 4 节）中观察到这一点。 Scylla 是一种分布式 NoSQL DBMS，在页面驱逐策略和 I/O 操作调度 [23] 方面评估了文件 I/O 的几种替代方案，并且由于失去细粒度控制而拒绝了 mmap。 时间序列 DBMS VictoriaMetrics 确定了 mmap 因缺页异常阻塞 I/O 的问题 [37]。 由于内存映射文件 I/O 的 Windows 和 POSIX 实现不兼容 [26]，RDF-3X 放弃了其最初基于 mmap 的引擎。表面上看，mmap 似乎是个好主意——DBMS 不再需要管理自己的 buffer pool ，因为它将此责任交给了操作系统。 通过删除处理显式文件 I/O 的组件，DBMS 开发人员可以自由地专注于系统的其他方面。 然而，透明分页实际上给 DBMS 带来了几个严重的问题，我们将在下面讨论这些问题。在基于 mmap 的 DBMS 中保证修改页面的事务安全所固有的挑战是众所周知的 [22, 18]。 核心问题是，由于透明分页，操作系统可以随时将脏页刷新到辅助存储，而不管写入事务是否已提交。 DBMS 无法阻止这些刷新并且在它们发生时不会收到警告。因此，基于 mmap 的 DBMS 必须采用复杂的协议来确保透明分页不会违反事务安全保证。 我们将处理更新的方法分为三类：(1) OS copy-on-write，(2) 用户空间 copy-on-write，和 (3) shadow paging。 为了简化我们的解释，我们假设 DBMS 将数据库存储在一个文件中。OS Copy-On-Write：这种方法背后的想法是使用 mmap 创建数据库文件的两个副本，这两个副本最初将指向相同的物理页面。 第一个用作主副本，而第二个用作事务可以暂存更新的私有工作区。 重要的是，DBMS 使用 mmap 的 MAP_PRIVATE 标志创建私有工作区，以启用操作系统的页面写时复制功能。 据我们所知，只有 MongoDB 的 MMAPv1 存储引擎使用了这种方法。为执行更新，DBMS 修改私有工作区中受影响的页面。 操作系统会将内容透明地复制到新的物理页面，将虚拟内存地址重新映射到这些副本，然后应用更改。 主副本看不到这些更改，操作系统不会将它们保存到数据库文件中。 因此，为了提供持久性，DBMS 必须使用预写日志 (WAL) 来记录更改。 当事务提交时，DBMS 将相应的 WAL 记录刷新到辅助存储，并使用单独的后台线程将提交的更改应用到主副本。维护更新页面的单独副本会导致两个主要问题。 首先，DBMS 必须确保已提交事务的最新更新已传播到主副本，然后才能允许冲突事务运行，这需要额外的簿记来跟踪具有待处理更新的页面。 其次，随着更多更新的发生，私有工作区将继续增长，并且 DBMS 最终可能会在内存中拥有数据库的两个完整副本。 为了解决第二个问题，DBMS 可以使用 mremap 系统调用定期缩小私有工作空间。 但是，DBMS 必须再次确保所有挂起的更新都已传播到主副本，然后再销毁私有工作区。 此外，为了避免在 mremap 期间丢失更新，DBMS 需要阻止挂起的更改，直到操作系统完成私有工作空间的压缩。用户空间写时复制：与操作系统写时复制不同，此方法涉及手动将受影响的页面从 mmapbacked 内存复制到用户空间中单独维护的缓冲区。 SQLite、MonetDB 和 RavenDB 都使用这种方法的一些变体。为了执行更新，DBMS 仅将更改应用于副本并创建相应的 WAL 记录。 DBMS 可以通过将 WAL 写入辅助存储来提交这些更改，此时它可以安全地将修改后的页面复制回 mmap 支持的内存。 由于复制整个页面对于小的更改来说是一种浪费，因此一些 DBMS 支持将 WAL 记录直接应用于 mmap 支持的内存。Shadow 分页：LMDB 是这种方法最突出的支持者，它基于 System R 的 shadow 分页设计 [13]。 通过 shadow 分页，DBMS 维护数据库的单独主副本和 shadow 副本，两者均由 mmap 支持。 为执行更新，DBMS 首先将受影响的页面从主页面复制到卷影副本，然后在其中应用必要的更改。 提交更改涉及使用 msync 将修改后的 shadow 页面刷新到辅助存储，然后更新指针以将 shadow 副本安装为新的主存储。 然后，原始主副本用作新的卷影副本。尽管这种方法实施起来似乎并不复杂，但 DBMS 必须确保事务不冲突或看到部分更新。 例如，LMDB 通过只允许一个 writer 来解决这个问题。对于传统的 buffer pool ，DBMS 可以使用异步 I/O（例如 libaio、io_uring）来避免在查询执行期间阻塞线程。 例如，考虑一种常见的访问模式，如 B+ 树中的叶节点扫描。 DBMS 可以异步发出对这些可能不连续的页面的读取请求以屏蔽延迟，但 mmap 不支持异步读取。此外，由于操作系统可以透明地将页面逐出到辅助存储，如果只读查询试图访问被逐出的页面，它们可能会在不知不觉中触发阻塞缺页异常。 换句话说，访问任何页面都可能导致意外的 I/O 停顿，因为 DBMS 无法知道该页面是否在内存中。为了避免这些问题，DBMS 开发人员可以使用第 2.2 节中描述的系统调用来实现变通方法。 最明显的选择是使用 mlock 固定 DBMS 希望在不久的将来再次访问的页面。 不幸的是，操作系统通常会限制单个进程可以锁定的内存量，因为固定太多页面可能会给并发运行的进程甚至操作系统本身带来问题。 DBMS 还需要仔细跟踪和取消固定不再使用的页面，以便操作系统可以驱逐它们。另一种可能的解决方案是使用 madvise 向操作系统提供有关查询的预期访问模式的提示。 例如，需要执行顺序扫描的 DBMS 可以向 madvise 提供 MADV_SEQUENTIAL 标志，它告诉操作系统在读取页面后逐出页面，并预取接下来将访问的后续连续页面。 这种方法比使用 mlock 涉及的更少，但它提供的控制也少得多，因为标志只是操作系统可以自由忽略的提示。 此外，向操作系统提供错误的提示（例如，当访问模式是随机的时，MADV_SEQUENTIAL）可能会对性能产生可怕的影响，正如我们在实验中展示的那样（第 4 节）。另一种可能性是产生额外的线程来预取（即尝试访问）页面，以便它们将在缺页异常而不是主线程的情况下阻塞。 然而，尽管这些解决方案可能（部分）解决了一些问题，但它们都引入了显着的额外复杂性，这首先违背了使用 mmap 的目的。DBMS 的一项核心职责是确保数据完整性，因此错误处理至关重要。 例如，一些 DBMS（例如 SQL Server [6]）维护页面级校验和以检测文件 I/O 期间的数据损坏。 从辅助存储读取页面时，DBMS 会根据存储在标头中的校验和来验证页面内容。 但是，对于 mmap，DBMS 需要在每次页面访问时验证校验和，因为操作系统可能在上次访问后的某个时间点透明地逐出该页面.类似地，许多 DBMS（包括 2.3 节中提到的几个）是用内存不安全语言编写的，这意味着指针错误可能会损坏内存中的页面。 防御性编码的 buffer pool 实现可以在将这些页面写入辅助存储之前检查这些页面是否存在错误，但是 mmap 会默默地将损坏的页面保存到支持文件最后，在使用 mmap 时，优雅地处理 I/O 错误变得更加困难。 传统的 buffer pool 允许开发人员在单个模块中包含 I/O 错误处理，而与 mmap 支持的内存交互的任何代码现在都可以产生 SIGBUS，DBMS 必须通过繁琐的信号处理程序来处理它。mmap 透明分页的最大和最显着的缺点与性能有关。 尽管 DBMS 开发人员可以通过谨慎实施来克服其他问题，但我们认为 mmap 存在严重的瓶颈，如果不进行操作系统级别的重新设计，这些瓶颈是无法避免的。传统观点 [28、23、29、16、17、30] 认为 mmap 应该优于传统的文件 I/O，因为它避免了两个主要的开销来源。 首先，mmap 规避了显式 read/write 系统调用的成本，因为操作系统在幕后处理文件映射和缺页异常。 其次，mmap 可以返回指向存储在操作系统页面缓存中的页面的指针，从而避免额外复制到用户空间中分配的缓冲区中。 作为一个额外的好处，基于 mmap 的文件 I/O 还可以降低总内存消耗，因为数据不会在用户空间中不必要地重复。鉴于这些优势，人们预计 mmap 和传统文件 I/O 方法之间的性能差距应该会随着更好的闪存存储（例如 PCIe 5.0 NVMe）的出现而继续扩大，这些闪存将提供与内存相当的带宽 [19]。 令人惊讶的是，我们发现对于高带宽辅助存储设备上大于内存的 DBMS 工作负载，操作系统的页面驱逐机制无法扩展到几个线程之外。 我们认为，这些性能问题基本上没有引起注意的主要原因之一是由于历史上文件 I/O 带宽有限。具体而言，我们确定了困扰基于 mmap 的文件 I/O 的三个关键瓶颈：(1) 页表争用，(2) 单线程页面逐出，以及 (3) TLB 击落。 对操作系统进行相对直接的调整可以部分缓解前两个问题，但 TLB 击落会带来更棘手的问题。回想一下 2.1 节，当内核需要使远程 TLB 中的映射无效时，TLB 击落发生在页面逐出期间。 虽然刷新本地 TLB 的成本很低，但发出处理器间中断以同步远程 TLB 可能需要数千个周期 [39]。 这个问题的解决方法涉及提议的微体系结构更改 [39] 或操作系统内部的广泛修改 [15、9、10]。正如上一节所解释的，mmap 的一些问题可以通过谨慎的实施来克服，但我们认为，如果不进行重大的操作系统级重写，就无法解决其固有的性能限制。 在本节中，我们将介绍我们的实验分析，以经验证明这些问题。我们在配备 AMD EPYC 7713 处理器（64 核，128 硬件线程）和 512 GB RAM 的单路机器上运行所有实验，其中 100 GB 可用于 Linux (v5.11) 的页面缓存。 对于持久存储，该机器有 10 × 3.8 TB 三星 PM1733 SSD（额定读取速度为 7000 MB/s，写入速度为 3800 MB/s）。 我们将 SSD 作为块设备进行访问，以避免潜在的文件系统开销 [19]。作为基准，我们使用带有直接 I/O (O_DIRECT) 的 fio [2] 存储基准测试工具 (v3.25) 来绕过操作系统页面缓存。 我们的分析专门针对只读工作负载，这代表了基于 mmap 的 DBMS 的最佳情况； 否则，他们将需要实施复杂的更新保护（第 3.1 节），这会产生大量额外开销 [30]。 具体来说，我们评估了两种常见的访问模式：(1) 随机读取和 (2) 顺序扫描。对于第一个实验，我们在 2 TB SSD 范围内使用随机访问模式来模拟大于内存的 OLTP 工作负载。 由于页面缓存只有 100 GB 的内存，95% 的访问都会导致缺页异常（即，工作负载受 I/O 限制）。图 2a 显示了 100 个线程每秒随机读取的次数。 我们的 fio 基线表现出稳定的性能并实现了每秒近 900K 次读取，这符合 100 次出色的 I/O 操作和大约 100 𝜇s 的 NVMe 延迟的预期性能。 换句话说，这个结果表明 fio 可以完全饱和 NVMe SSD。另一方面，mmap 的性能明显更差，即使使用与工作负载的访问模式匹配的提示也是如此。 我们在实验中观察到 MADV_RANDOM 的三个不同阶段。 mmap 最初在前 27 秒内与 fio 相似，然后在大约 5 秒内下降到接近零，最后恢复到 fio 性能的一半左右。 这种性能突然下降发生在页面缓存填满时，迫使操作系统开始从内存中逐出页面。 毫不奇怪，其他访问模式提示表现出更差的性能。在 3.4 节中，我们列举了页面驱逐开销的三个主要来源。 第一个问题是 TLB 击落，我们使用 /proc/interrupt 测量并显示在图 2b 中。 如前所述，TLB 击落代价高昂（即数千个周期 [39]），因为它们涉及发送处理器间中断以刷新每个内核的 TLB。 其次，操作系统仅使用单个进程 (kswapd) 进行页面驱逐，这在我们的实验中受 CPU 限制。 最后，操作系统必须同步页表，这与许多并发线程竞争激烈。顺序扫描是 DBMS 的另一种常见访问模式，尤其是在 OLAP 工作负载中。 因此，我们还比较了 fio 和 mmap 在 2 TB SSD 范围内的扫描性能。 我们首先仅使用一个 SSD 运行实验，然后使用 10 个带软件 RAID 0 (md) 的 SSD 重新运行相同的工作负载。图 3 中的结果表明，fio 可以利用一个 SSD 的全部带宽，同时保持稳定的性能。 与之前的实验一样，mmap 的性能最初与 fio 相似，但我们再次观察到页面缓存在大约 17 秒后填满后性能急剧下降。 此外，正如预期的那样，对于此工作负载，MADV_NORMAL 和 MADV_SEQUENTIAL 标志的性能优于 MADV_RANDOM。图 4 显示了使用 10 个 SSD 重复顺序扫描实验的结果，进一步突出了现代闪存存储理论上可以提供的内容与 mmap 可以实现的内容之间的差距。 我们观察到 fio 和 mmap 之间大约有 20 倍的性能差异，而 mmap 与使用一个 SSD 的结果相比几乎没有任何改进。总之，我们发现 mmap 在初始加载阶段仅在单个 SSD 上表现良好。 一旦页面逐出开始或使用多个 SSD 时，mmap 比 fio 差 2-20 倍。 随着 PCIe 5.0 NVMe 即将发布，预计每个 SSD 的带宽将增加一倍，我们的结果表明 mmap 无法与传统文件 I/O 的顺序扫描性能相媲美。据我们所知，还没有对于在现代 DBMS 中使用基于 mmap 的文件 I/O 相关的问题进行深入研究。 在下文中，我们描述了一些先前的研究工作，这些研究工作检查了 mmap 的不同方面。鉴于使用 mmap 时确保事务安全的问题，一项工作引入了新的故障原子 msync 系统调用 [31、38]。 通常，如果系统在调用 msync 期间崩溃，DBMS 无法知道哪些页面已成功写入辅助存储。 Failure-atomic msync 提供与 msync 相同的 API，但确保所有涉及的页面都是原子写入的。 作为实现的副作用，failureatomic msync 禁用操作系统透明地逐出页面的能力，这消除了对我们在第 3.1 节中描述的许多安全机制的需要。Tucana [28] 和 Kreon [29] 是围绕基于 mmap 的文件 I/O 构建的实验性键值 DBMS。 然而，他们都注意到了 mmap 的几个核心问题（例如，失去对 I/O 调度的细粒度控制），这促使 Kreon 实现了自己的自定义系统调用（kmmap）。 这些系统还必须结合复杂的写时复制方案以确保事务的一致性其他研究项目以超越 buffer pool 替代的方式创造性地使用了 mmap。 例如，一个项目通过 mmap 利用操作系统的虚拟分页机制作为一种低开销的方式将冷数据迁移到二级存储 [35]。 RUMA 利用 mmap 来“重新布线”页面映射以执行各种操作（例如，排序）而无需物理复制数据 [33]。最后，最近的几种方法 [18、24、25] 提倡指针调配，而不是依赖 mmap 来避免页面映射开销。 正如我们在本文中所讨论的那样，我们相信这些轻量级缓冲区管理技术是正确的方法，因为它们可以提供与 mmap 类似的性能而没有任何缺点。本文反对在 DBMS 中将 mmap 用于文件 I/O。 尽管有明显的好处，我们还是介绍了 mmap 的主要缺点，并且我们的实验分析证实了我们与性能限制相关的发现。 最后，我们为 DBMS 开发人员提供以下建议。何时不应在 DBMS 中使用 mmap： 你需要以事务安全的方式执行更新。 你希望在不阻塞慢速 I/O 的情况下处理页面错误，或者需要明确控制内存中的数据。 你关心错误处理并需要返回正确的结果。 您需要在快速持久存储设备上实现高吞吐量。什么时候应该在 DBMS 中使用 mmap： 您的工作集（或整个数据库）适合内存并且工作负载是只读的。 您需要将产品快速推向市场，而不关心数据一致性或长期的工程难题。 否则，永远不要。" }, { "title": "brpc学习-bthread", "url": "/posts/brpc-1/", "categories": "计算机, 其他", "tags": "", "date": "2022-10-17 16:03:15 +0800", "snippet": "brpc简介brpc 是一个 C++ 编写的高性能分布式 RPC 框架，最初由百度于 2014 年创建，在 2017 年开源，于 2018 年进入 Apache 孵化器。如今 brpc 已经被广泛地应用于各大公司，包括百度、字节跳动、滴滴、bilibili、网易等。整体架构一个RPC的基本流程： Client 通过 Channel（通道，可视为命名服务的 Client）进行 RPC 调用 通过命名服务中的 Server 列表和某种负载均衡算法找到访问的 Server 使用某种协议进行序列化请求通过套接字发送 Sever 反序列化通过方法名找到对应服务 Sever 执行方法调用后将结果返回给 Client bthread 线程库介绍bthread 是 brpc 使用的 M:N 线程库，M:N 是指 M 个用户级线程（bthread）会映射至 N 个内核级线程（pthread），一般M远大于N。 设计目标 用户可以延续同步的编程模式，能在数百纳秒内建立 bthread，可以用多种原语同步。 bthread 所有接口可在 pthread 中被调用并有合理的行为，使用 bthread 的代码可以在 pthread 中正常执行。 能充分利用多核。 整体设计TaskMeta 每个 bthread 对应一个 TaskMeta，TaskMeta 即 bthread 下 task 的元信息，包括任务处理的上下文，bthread 的 id 等TaskGroup 意思为 Thread-Local group of tasks，一个 TaskGroup 是线程的单例，是一个 Thread Local Storage 变量 负责调度 bthread 和管理调度队列 rq 和 remote_rq TaskControl 是进程的单例，负责创建和管理 TaskGroup执行流程开启 bthreadbthread 的启动入口函数有两个： bthread_start_urgent()：让出当前 worker 立即执行新的 bthread bthread_start_background()：将要启动的 bthread 放入队列等待调度 使用示例// 用于保存 bthread 的 idsstd::vector&amp;lt;bthread_t&amp;gt; tids(3);for (size_t i = 0; i &amp;lt; tids.size(); ++i) { // 开启后台 bthread，开启的 bthread id 保存在 tid[i] 中 bthread_start_background(&amp;amp;tids[i], nullptr, fn, arg);}std::vector&amp;lt;void*&amp;gt; res(tids.size());for (size_t i = 0; i &amp;lt; tids.size(); ++i) { // 等待执行结束，返回值保存在 res[i] 中 bthread_join(tids[i], &amp;amp;res[i]);} 如果 caller 不是 worker 线程，任务加入 remote_rq 如果 caller 是 worker 线程，任务加入 rq 调度常见的调度策略 星切调度main task -&amp;gt; task1 -&amp;gt; main task -&amp;gt; task2 -&amp;gt; main task -&amp;gt; task3 -&amp;gt; … -&amp;gt; main task 环切调度main task -&amp;gt; task1 -&amp;gt; task2 -&amp;gt; task3 -&amp;gt; … -&amp;gt; main task 对比两种调度策略，环切调度次数是星切调度的一半，但同时实现难度会更大，task 运行完成后要主动调用切换方法，在被切换后如何回收内存等，bthread 采用了环切调度。TaskGroupclass TaskGroup { // ... size_t _steal_seed; // work stealing 算法随机数种子 size_t _steal_offset; // work stealing 算法随机数偏移量 // main bthread，调度线程 ContextualStack* _main_stack; bthread_t _main_tid; WorkStealingQueue&amp;lt;bthread_t&amp;gt; _rq; // 通过 worker 添加 RemoteTaskQueue _remote_rq; // 非 worker 添加};Work Sharing在介绍 Work Stealing 之前，先介绍一下 Work sharing 工作共享算法。在该算法中，所有的线程共享一个全局的任务队列，虽然实现起来会简单些，但是很明显的是队列的竞争会很严重，因此，让每个 Thread 有自己的调度队列，同时为了负载均衡采取 Work Stealing 算法是更优的方法。Work StealingWork Stealing 即工作窃取算法，是一种实现 CPU 负载均衡的方式，使 CPU 在处理任务时，每个核的负载均衡。在 bthread 中，这里的工作窃取是某一个 worker 线程通过调度器从其他 worker 线程的任务队列中获取任务。具体流程分析前面讲到每个 worker 线程开启的时候就会运行 run_main_task()void TaskGroup::run_main_task() { TaskGroup* dummy = this; bthread_t tid; while (wait_task(&amp;amp;tid)) { TaskGroup::sched_to(&amp;amp;dummy, tid); // ... if (_cur_meta-&amp;gt;tid != _main_tid) { TaskGroup::task_runner(1); } // ... }}从代码可以看出 run_main_task() 执行的是一个无限循环，三个关键函数： wait_task：等待获取一个任务，其中包括从自身队列中获取和从其他 worker 线程中获取 sched_to：进行调度，包括进行栈、寄存器等上下文的切换 task_runner：执行 bthread wait_task()伪代码如下：bool TaskGroup::wait_task(bthread_t* tid) { // 1. 等待 parking lot，可以理解为一个 bthread 到来的条件变量 // 2. 执行 steal_task(tid)，成功返回 true}bool TaskGroup::steal_task(bthread_t* tid) { // 1. 优先从本 _remote_rq 中获取 if (_remote_rq.pop(tid)) { return true; } // ... // _control 是本 TaskGroup 所属的 TaskControl 指针 return _control-&amp;gt;steal_task(tid, &amp;amp;_steal_seed, _steal_offset);}bool TaskControl::steal_task(bthread_t* tid, size_t* seed, size_t offset) { bool stolen = false; size_t s = *seed; // ngroup 是所有 TaskGroup 的数量 for (size_t i = 0; i &amp;lt; ngroup; ++i, s += offset) { // _groups 数组保存所有该 TaskControl 下的 TaskGroup 指针 TaskGroup* g = _groups[s % ngroup]; if (g) { // 2. 从随机 TaskGroup 的 _rq 队列中取 if (g-&amp;gt;_rq.steal(tid)) { stolen = true; break; } // 3. 从随机 TaskGroup 的 _remote_rq 中取 if (g-&amp;gt;_remote_rq.pop(tid)) { stolen = true; break; } } } // ... // 更新随机数种 *seed = s; return stolen;}可以看出一个 worker 线程执行 bthread 的调度策略的优先级是： 从自己的 remote_rq 中获取 从随机 worker 的 rq 中获取 从随机 worker 的 remote_rq 中获取 设计原因：本质上是为了更好的实现 bthread 的分配和减少 worker 线程之间 steal 时的竞争 区分 remote_rq 和 rq 可以使 worker 能在自己 remote_rq 获取时，不必和其他 worker的 rq 窃取竞争 从自己的 remote_rq 中获取到从随机 worker 的 remote_rq 中隔了一层随机 worker 的rq 获取来减小从自己remote_rq的竞争 在自己 remote_rq 中获取不到时不直接从自己的 rq 中获取是为了避免直接和其他前来窃取的 worker 竞争 sched_to()void TaskGroup::sched_to(TaskGroup** pg, TaskMeta* next_meta) { TaskGroup* g = *pg; ... // Switch to the task // cur_meta 是当前执行的 TaskMeta // __builtin_expect(next_meta != cur_meta, 1) 的意思是极大可能 next_meta != cur_meta，在此处是绝不可能 // __builtin_expect 用于编译器优化条件分支语句 if (__builtin_expect(next_meta != cur_meta, 1)) { ... if (cur_meta-&amp;gt;stack != NULL) { if (next_meta-&amp;gt;stack != cur_meta-&amp;gt;stack) { // 切换栈 jump_stack(cur_meta-&amp;gt;stack, next_meta-&amp;gt;stack); } ... } } else { LOG(FATAL) &amp;lt;&amp;lt; &quot;bthread=&quot; &amp;lt;&amp;lt; g-&amp;gt;current_tid() &amp;lt;&amp;lt; &quot; sched_to itself!&quot;; } ...}在函数 jump_stack() 中，进行了栈的切换task_runner()void TaskGroup::task_runner(intptr_t skip_remained) { TaskGroup* g = tls_task_group; do { // 当前运行 bthread 上下文 TaskMeta* const m = g-&amp;gt;_cur_meta; ... 执行 bthread 函数 ... // 执行 ending_sched ending_sched(&amp;amp;g); } while (g-&amp;gt;_cur_meta-&amp;gt;tid != g-&amp;gt;_main_tid);}void TaskGroup::ending_sched(TaskGroup** pg) { TaskGroup* g = *pg; bthread_t next_tid = 0; ... const bool popped = g-&amp;gt;_rq.steal(&amp;amp;next_tid); if (!popped &amp;amp;&amp;amp; !g-&amp;gt;steal_task(&amp;amp;next_tid)) { // _rq 已经没有任务并且其他 TaskGroup 也没有任务时 // 重置为 main bthread next_tid = g-&amp;gt;_main_tid; } TaskMeta* const cur_meta = g-&amp;gt;_cur_meta; TaskMeta* next_meta = address_meta(next_tid); ... sched_to(pg, next_meta);}可以看出 task_runner() 是一个循环，先是执行之前获取到的 bthread，执行完后进入 ending_sched()，先是尝试从 rq 队列中取任务，如果失败再次从其他 TaskGroup 中取任务，当两者都失败时才会把当前运行的 bthread 设置为 main bthread，用来退出 task_runner 的循环，重新回到 wait_task()，这样设计能够在大量 bthread 时减少 wait_task 的调用次数，从而提高效率。思考与 goruntine 的异同 特性 bthread goruntine 本地存储 yes no 优先级 no no 并发效率 高 高 创建时延 0.2us - 抢占 no yes 易用性 还行 强 最大数量 少于 goruntine 超级多 调度时延 3-20us (越忙越快) 3us-10ms (gc) 线程池调整线程数 no yes bthread 和 goruntine 都是基于线程池技术实现的 M:N 线程模型，在 CPU 负载均衡上都采用了 Work Stealing 算法 bthread 的栈大小并不是动态的，但是提供了 3 种大小的栈（32KB、1MB、8MB），goruntine 使用的栈是可动态变化的（初始2KB） bthread 并不是一个完备的线程库，并没有支持优先级和抢占，主要原因是它纯粹为了 rpc 这种场景而设计的，主要目的在于高效地创建和调度，但是还是提供了bthread_start_urgent() 来保证优先执行，还有 bthread_join() 等原语同步 goruntine是一个系统级完备的 M:N 线程库，在设计上要比 bthread 复杂的多 通过学习 bthread，已经可以了解到 M:N 线程模型的基本实现。" }, { "title": "C++的一些在线工具", "url": "/posts/C++%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/", "categories": "计算机, C++", "tags": "", "date": "2022-10-17 16:03:15 +0800", "snippet": "C++的一些在线工具看代码编译展开https://cppinsights.io/benchmarkhttps://quick-bench.com/编译开销https://build-bench.com/看编译成的汇编https://gcc.godbolt.org/" }, { "title": "C++ memory order", "url": "/posts/C++-memory-order/", "categories": "计算机, C++", "tags": "", "date": "2022-10-17 16:03:15 +0800", "snippet": "memory_order_relaxed没有同步或顺序制约，仅对此操作要求原子性memory_order_release 对写操作施加 release 语义，在代码中这条语句前面的所有读写操作都无法被重排到这个操作之后 当前线程内的所有写操作，对于其他对这个原子变量进行 acquire 的线程可见 当前线程内的与这块内存有关的所有写操作，对于其他对这个原子变量进行 consume 的线程可见memory_order_consume 对当前要读取的内存施加 consume 语义，在代码中这条语句后面所有与这块内存有关的读写操作都无法被重排到这个操作之前 在这个原子变量上施加 release 语义的操作发生之后，consume 可以保证读到所有在 release 前发生的并且与这块内存有关的写入memory_order_acquire 对读操作施加 acquire 语义，在代码中这条语句后面所有读写操作都无法重排到这个操作之前 在这个原子变量上施加 release 语义的操作发生之后，acquire 可以保证读到所有在 release 前发生的写入memory_order_acq_rel作用在 read-modify-write 操作上，同时具备 memory_order_acquire、memory_order_release 的语义memory_order_seq_cst同时具备 memory_order_acquire、memory_order_release、memory_order_acq_rel 的语义，额外保证所有 memory_order_seq_cst 作用的变量具备全局序" }, { "title": "C++ Lambda", "url": "/posts/C++-Lambda/", "categories": "计算机, C++", "tags": "", "date": "2022-10-17 16:03:15 +0800", "snippet": "完整的声明格式：[capture list] (params list) mutable exception-&amp;gt; return type { function body }例子：[](int a, int b) -&amp;gt; bool { return a &amp;lt; b; }捕获： 值捕获 int main() { int a = 123; auto f = [a] { cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; }; a = 321; f(); // 输出：123} 引用捕获 int main() { int a = 123; auto f = [&amp;amp;a] { cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; }; a = 321; f(); // 输出：321} 隐式值捕获 int main() { int a = 123; auto f = [=] { cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; }; f(); // 输出：123} 隐式引用捕获 int main() { int a = 123; auto f = [&amp;amp;] { cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; }; a = 321; f(); // 输出：321} 在 Lambda 表达式中，如果以传值方式捕获外部变量，则函数体中不能修改该外部变量，否则会引发编译错误。这时就需要使用 mutable 关键字，该关键字用以说明表达式体内的代码可以修改值捕获的变量：int main() { int a = 123; auto f = [a]() mutable { cout &amp;lt;&amp;lt; ++a; }; cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; // 输出：123 f(); // 输出：124}参数： 参数列表中不能有默认参数 不支持可变参数 所有参数必须有参数名编译产物：不带捕获时，会多一个 retType，用于当作函数指针传递。// auto add = [](int a, int b) -&amp;gt; int { return a + b; };class __lambda_6_14 { public: inline int operator()(int a, int b) const { return a + b; } using retType_6_14 = auto(*)(int, int) -&amp;gt; int; inline constexpr operator retType_6_14() const noexcept { return __invoke; }; private: static inline int __invoke(int a, int b) { return __lambda_6_14{}.operator()(a, b); }};带捕获(值捕获或引用捕获)时，不能当作函数指针传递，所以自然就不包含 retType。// auto add = [&amp;amp;](int a, int b) -&amp;gt; int { return a + b; };class __lambda_10_14 { public: inline int operator()(int a, int b) const { return a + b; } };" }, { "title": "行存和列存", "url": "/posts/%E8%A1%8C%E5%AD%98%E5%92%8C%E5%88%97%E5%AD%98/", "categories": "计算机, DB", "tags": "", "date": "2022-10-01 16:03:15 +0800", "snippet": "行存存储 vs 列存存储简介在 OLAP 场景下，我们通常倾向于使用列存（Column-Store）而不是行存（Row Store），做出这种决定的原因很直接：因为列存的 I / O 效率比行存更高，查询数据时，只需要从磁盘（或内存）中读取必要的列即可，具备更好的查询性能。但列存带来的性能提升，到底是因为其在内部架构的基本原理导致的，还是由于列存这一设计思想而导致的？我们是否可以在传统的行存数据库中应用一些具备列存特性的优化，从而使其性能和列存别无二致？根据列存的特性，我们可以对行存进行一定的优化，如 垂直分表，逐列分为若干个包含两列（主键、列值）的表，同样可以达到列存的“按需读取”的效果 全表的索引，为表的每一列都建立索引，保证查询计划中只存在 IndexScan，这样在查询过程中可以完全避免回表 物化视图，针对所有查询做物化视图，以获取最佳的查询性能。经过模拟实验，作者得出了结论，在进行了以上优化后，OLAP 场景下行存的查询性能依然无法与列存匹敌。因为列存存在如下几个可以提高查询性能的关键优化： 延迟物化，从磁盘读取到的列在查询计划中尽可能晚地连接成行 块迭代（Block Iteration），在多个 Operator 之间通过块（Block）方式批量传递一列的多个数据 数据压缩，根据列存的数据特性可以进行压缩，如性别“男”“女”可以用位图 1、0 来代替 隐式连接（作者提出的一种 join 方式）作者通过逐个移除 C-Store 中上述的优化手段，得出了结论 压缩带来的性能提升要看具体的数据，最多时可以提升一个数量级 延迟物化可以提升 3 倍 块迭代和隐式连接可以提升约 1.5 倍行存的优化上文提到了可以基于基于列存的设计思想来对行存系统进行优化，下面介绍下三种优化方式垂直分表模仿列存的一个简单粗暴的方法就是把表的每一列都垂直拆分，拆分之前，一行数据是连续存储的，但是拆分之后一行的数据可能分散在磁盘各处，因此需要额外的机制来把某行记录的每一列联系起来（列存则不需要这种机制，因为列存数据写入会使用一个统一的 Sort Key，使得记录是“对齐”的）。第一反应可能需要在每个表中增加主键字段，但是主键字段可能会比较大，并且很多时候主键是复合主键，所以可以改为向每个表添加一个整数类型的 “Position” 列，用于标识其所属的行。最终拆下来，一个 n 列的表会被拆分成共计 2n 列的 n 张表。一旦列数目增加，连续 Join 会使得查询更加复杂。全表索引垂直分表的方案存在两个问题 它需要在每一列上增加一个 Position 列用来还原之前的记录，这会浪费盘空间和磁盘带宽； 行存数据库物理存储一条记录时，会额外存储记录头信息，垂直分表产生了海量“短”记录，从而带来的海量记录头信息，进一步导致了磁盘空间的膨胀。为了解决以上问题，作者考虑 Index-Only 的方式，原来的表数据依然采用原汁原味的行存，但是在每一列上都建立二级索引。最终查询时，通过对应字段的索引来过滤出各种主键列表，然后做合并计算，完全避免了对原始表的扫描。和垂直分表的方式相比，虽然每个二级索引都额外存储了Row ID，但是索引结构中就不含有记录头信息，可以少占用一些磁盘空间。物化视图完全根据预定义的 SQL 来生成确定的物化视图，且其中不会关联多余的列。显然这种方式查询性能很好，I/O 效率高，但这种方法又只能应付极其极其极其有限的场景。列存的优化数据压缩压缩，就是将相似度很高、信息熵很低的数据放在一起，用更小的空间表达相同的信息量，压缩带来的优势有： 更少的磁盘空间占用，不过磁盘已经越来越便宜了，我们不差钱，我们更看重的是 提高性能，显然在从磁盘上读取压缩后的数据时，I / O 效率会更高当然追求极致压缩也是不可取的，如果压缩后的数据无法被查询引擎直接识别，反而会额外带来解压的代价，因此可以考虑“轻量级”一点的压缩方案，使得查询引擎可以直接识别/操作压缩后的数据，这样子避免了解压过程，进一步提高了查询性能。如：RLE（Run-Length Encoding）压缩算法，（AAAAAAAAAAAAAAAA -&amp;gt; 16A），如果遇到了 SUM，AVG 操作符，可以免解压直接得出结果。当然行存也是可以压缩的（见 InnoDB Row Formats），MySQL 提供了若干种压缩级别的行存方案，不过行存的压缩效率和列存的压缩效率存在本质上的差距，因为列存的数据往往类型相同，相同的特征更多，更容易被压缩；行存中一列数据周围因为可能存在关联不大的其他列，会显著提高压缩的复杂度。如果一列的数据是被排序过的（更低的熵），压缩起来会更加容易，这一点是行存无法达到的。延迟物化在实际编写代码查询数据库时，我们用对象（原文 Entity，现在大家基本都用面向对象编程，我就用对象这个说法了）承载查询出来的数据，一条查询结果（一行数据）对应一个对象。在列存中，一个表的字段是分散存储的，而承载查询结果的对象可能涵盖了多个表的多个字段，所以如何把列存存储的数据从磁盘中取出，并组织构建成行存的形式（一个对象）是列存数据库需要频繁进行的一个操作，这个操作就叫做物化。（列转行）既然标题叫“延迟物化”，那么说明物化的时机是可以选择的： 早期物化，会第一时间就把列数据从磁盘中取出来，转化为行存的形式，然后按部就班根据 SQL 执行一个个 Operator。 延迟物化则可以将物化的时机放到查询计划执行的后期，先不拼出行式数据，直接在 Column 数据上分别应用两个过滤条件，从而得到两个满足过滤条件的 bitmap，然后再把两个 bitmap 做位与的操作得到同时满足两个条件的所有的 bitmap，之后只需要根据 bitmap 即可查询必要的记录。作者提出，延迟物化有以下优势 selection 和 aggregation 操作很有可能不需要整行数据，延迟物化会避免不必要的资源浪费； 如果数据是被压缩过的，早期物化就必须对数据进行解压，反而对冲了压缩存储带来的性能优势； 列式的内存组织形式对 CPU Cache 非常友好，从而提高计算效率，相反行存的组织形式因为非必要的列占用了 Cache Line 的空间，Cache 效率低； 块遍历的优化手段对 Column 类型的数据效果更好，因为数据以 Column 形式保存在一起，数据是定长的可能性更大，而如果 Row 形式保存在一起数据是定长的可能性非常小（因为一行数据但凡有一个字段是非定长的，比如 VARCHAR，那么整行数据都是非定长的）。延迟物化 vs 早期物化不过延迟物化并非一定胜过早期物化，因为将条件直接应用在列上并获得 bitmap 一定伴随着扫描磁盘的行为，也是存在代价的。文章 Materialization Strategies in a Column-Oriented DBMS 提出，如果一条 SQL 中某个列上存在多个谓词，那么查询计划中就有可能需要扫描该列多次（来获取若干个 bitmap），就算查询计划安排合理（第一次就从磁盘中读到 buffer 里，后续就不用反复磁盘扫描了），也会带来额外的 CPU 计算代价，相反早期物化第一时间就将目标列转化成中间态的形式，随着 Opeartor 执行自然过滤数据，避免了额外的计算开销。假设有个极端查询：SELECT Name，Age FROM Employee WHERE Age &amp;gt; 18 AND Age &amp;lt; 88 AND Age != 26这种场景下延迟物化反而导致了更多的扫描次数。块迭代一般来说，查询计划处理模型有三种（根据 CMU 的课程，https://15445.courses.cs.cmu.edu/fall2021/notes/11-queryexecution1.pdf）： 迭代器模型（又称火山模型）：火山模型是一个发展比较成熟的查询计划处理模型，该模型将关系代数中每一种操作抽象为一个 Operator，将整个 SQL 构建成一个 Operator 树，从根节点到叶结点自上而下地递归调用 next() 函数，每次 next() 只返回一条数据。 物化模型（Materialization Model）：每个 Operator 一次处理所有的输入，处理完之后将所有结果一次性输出，物化模型更适合 OLTP 负载，查询每次只访问小规模的数据。这种处理模型需要尽可能地进行一些条件下推，以免最下层的 Operator 把整张表都捞出来。 批量模型（Vectorized / Batch Model）：是以上两者的一个折中，每个 Operator 的 next() 都会返回一批数据，具体的数据量可以根据实际的硬件条件来决定。Block Iteration 这种说法表达的就是批量处理模型。行存和列存都可以采用这种查询处理模型，然而列存天然更加适合批量处理模型。列存在使用批量处理模型时，多条数据的同一列是连续存储的，可以认为这些数据是以数组的方式存储的（如果数据类型是定长的），基于这样的特征，当该列数据需要进行某一同样操作，可以使用 SIMD 进一步提升计算效率，即便运算的机器上不支持 SIMD，也可以通过一个循环来高效完成对这个数据块各个值的计算。批量模型和列存的结合能够充分利用底层 CPU 的向量化计算能力，因此批量模型基本都被称作是“向量化”了。" }, { "title": "gdb", "url": "/posts/gdb/", "categories": "计算机, 其他", "tags": "", "date": "2022-09-10 16:03:15 +0800", "snippet": "gdbGDB 是一个由 GNU 开源组织发布的、UNIX/LINUX 操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名 Linux 下工作的 C++ 程序员，gdb 是必不可少的工具。启动 gdb对 C/C++ 程序的调试，需要在编译前就加上 -g 选项：g++ -g hello.cpp -o hello调试可执行文件：gdb &amp;lt;program&amp;gt;program 也就是你的执行文件。调试 core 文件：gdb &amp;lt;program&amp;gt; &amp;lt;core dump file&amp;gt;gdb program core.11127调试服务程序：gdb &amp;lt;program&amp;gt; &amp;lt;PID&amp;gt;gdb hello 11127如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的 PID。gdb 会自动 attach 上去。gdb 交互启动 gdb 后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率。运行 run：缩写为 r，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。 continue：缩写为 c，继续执行，到下一个断点处（或运行结束）。 next：缩写为 n，单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。 step：缩写为 s，单步调试，如果有函数调用，则进入函数；与命令 n 不同，n 不进入调用的函数。 until：运行程序直到退出循环体。 until + 行号： 运行至某行，不仅仅用来跳出循环。 finish：运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。 call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(123)。 quit：缩写为 q ，退出 gdb。设置断点 break + 行号：简写 b n，在第 n 行处设置断点（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）。 b fn1 if a＞b：条件断点设置。 break func：break 缩写为 b，在函数 func 的入口处设置断点，如：break cb_button。 delete 断点号 n：删除第 n 个断点。 disable 断点号 n：暂停第 n 个断点。 enable 断点号 n：开启第 n 个断点。 clear 行号 n：清除第 n 行的断点。 info b（info breakpoints）：显示当前程序的断点设置情况。 delete breakpoints：清除所有断点。 查看源代码 list ：缩写为 l，其作用就是列出程序的源代码，默认每次显示 10 行。 list 行号：将显示当前文件以“行号”为中心的前后 10 行代码，如：list 12。 。list 函数名：将显示“函数名”所在函数的源代码，如：list main。 list：不带参数，将接着上一次 list 命令的，输出下边的内容。打印表达式 print 表达式：缩写为 p，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试 C 语言的程序，那么“表达式”可以是任何 C 语言的有效表达式，包括数字，变量甚至是函数调用。 print a：将显示整数 a 的值。 print ++a：将把 a 中的值加1，并显示出来。 print name：将显示字符串 name 的值。 print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数。 print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数。 display 表达式：在单步运行时将非常有用，使用 display 命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如：display a。 watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb 将强行终止正在被调试的程序。如：watch a。 whatis：查询变量或函数。 info function：查询函数。 info locals：显示当前堆栈页的所有变量。查询运行信息 where/bt：当前运行的堆栈列表。 bt backtrace：显示当前调用堆栈。 up/down：改变堆栈显示的深度。 set args 参数：指定运行时的参数。 show args：查看设置好的参数。 info program：查看程序的是否在运行，进程号，被暂停的原因。分割窗口 layout：用于分割窗口，可以一边查看代码，一边测试。 layout src：显示源代码窗口。 layout asm：显示反汇编窗口。 layout regs：显示源代码/反汇编和 CPU 寄存器窗口。 layout split：显示源代码和反汇编窗口。 Ctrl + L：刷新窗口。" }, { "title": "InnoDB-Row Format", "url": "/posts/InnoDB-Row-Format/", "categories": "计算机, MySQL", "tags": "", "date": "2022-08-30 16:03:15 +0800", "snippet": "InnoDB 数据记录的存储格式：Row Format 行格式在 MySQL 中，所谓 Row Format 行格式是指数据记录(或者称之为行)在磁盘中的物理存储方式。具体地，对于 InnoDB 存储引擎而言，常见的行格式类型有 Compact、Redundant、Dynamic 和 Compressed。 Compact其大体分为两部分：记录的额外信息、记录的数据内容。记录的额外数据：变长字段的长度列表，NULL 值标识位，记录头信息记录的数据内容：列 1 数据，列 2 数据，…，列 n 数据变长字段的长度列表： 变长字段的长度列表不存储值为 NULL 的长度信息 变长字段的长度列表不是一定存在的一方面，表中可能没有变长类型的字段；另一方面，该记录中所有的变长字段值可能均为 NULL 变长字段的长度列表中各字段长度信息是按列的顺序逆序排列的 char 类型字段的长度信息是否需要存储在变长字段的长度列表中，取决于其所使用的字符集是否为变长字符集NULL 值标志位： 记录中的 NULL 值使用 bitmap 存储bitmap 中不存储 NOT NULL 的字段 NULL 值标志位不是一定存在的可能所有字段均为 NOT NULL bitmap 是按列的顺序逆序排列的记录头信息：记录头信息用于描述该条记录，其固定为 5 个字节，即 40 位。其定义如下：1 bit：预留位11 bit：预留位2：暂未使用1 bit：delete_mask：当前记录被删除的标志位1 bit：min_rec_mask：B+ 树的每层非叶子节点中的最小记录的标志位4 bits：n_owned：当前记录拥有的记录数13 bits：heap_no：当前记录在记录堆中的位置3 bits：record_type：当前记录类型。具体地，0: 普通记录；1: B+树非叶子节点记录（即所谓的目录项记录）；2: 最小记录；3: 最大记录16 bits：next_record：下一条记录的相对位置记录的数据内容：对于我们所定义的数据表，还会默认的插入一些其他列(字段)，即所谓的隐藏列。DB_ROW_ID：该字段占 6 个字节，用于标识一条记录DB_TRX_ID：该字段占 6 个字节，其值为事务IDDB_ROLL_PTR：该字段占 7 个字节，其值为回滚指针上述 3 个字段，除了 DB_ROW_ID 字段，其余两个字段均一定会被添加到数据表中。一般地，当用户未指定主键时，MySQL 会选择非 NULL 的 Unique 键作为主键。如果没有非 NULL 的 Unique 键的话，MySQL 才会添加 DB_ROW_ID 字段作为主键。行溢出众所周知，InnoDB 中内存与硬盘交互的基本单位是页，一般页大小为16KB。MySQL 规定一个页中至少需要存放两条记录。而所谓的行溢出是指：当某个记录的某个字段（varchar、text、blob 等类型）的值长度过长、数据量过大，会导致一个页中放不下一条记录，为此在 compact、redundant 行格式中，如果该记录某字段中数据量过多时，则在该记录的数据内容的相应字段处只存储该字段值前 768 个字节的数据和一个指向存储剩余数据的其他页（即所谓的溢出页）的地址，该地址通常占用 20 个字节。 Dynamic 和 CompressedDynamic、Compressed 和 Compact 比较相似，不同之处在于对待行溢出的处理。Dynamic、Compressed 会把溢出的字段值全部存储到溢出页中，而不会在原相应字段存储前 768 个字节。而 Compressed 相比于 Dynamic 来说，Compressed 会对所有页面进行压缩以减少存储占用。" }, { "title": "InnoDB-BufferPool-LRU", "url": "/posts/InnoDB-LRU/", "categories": "计算机, MySQL", "tags": "", "date": "2022-08-25 16:03:15 +0800", "snippet": "BufferPoolInnodb为了解决磁盘上磁盘速度和CPU速度不一致的问题，在操作磁盘上的数据时，先将数据加载至内存中，在内存中对数据页进行操作。Mysql在启动的时候，会向内存申请一块连续的空间，这块空间名为Bufffer Pool，也就是缓冲池，默认情况下Buffer Pool只有128M。简单的LRU： 新数据插入到链表头部； 每当缓存命中（即缓存数据被访问），则将数据移到链表头部； 当链表满的时候，将链表尾部的数据丢弃。不能用简单的 LRU 有以下原因： 假如有一张表被全表扫，就会迅速清空之前其他查询留下来的高频数据页，相当于 LRU list 被刷了一遍。 InnoDB 有预读机制 线性预读：当一个区中有连续 56 个（默认值）页面被加载到 BufferPool 中，会将这个区中所有页面都加载到 BufferPool 中。默认一个区 64 个页。 随机预读：当一个区中随机 13 个（默认值）页面被加载到 BufferPool 中，会将这个区中的所有页面都加载到 BufferPool 中。 InnoDB 的 LRU将链表分为两个部分，一个 old 区，一个 young 区。 young 区在链表的头部，理解为热数据 old 区在链表的尾部，理解为冷数据 当数据页第一次被加载进 BufferPool 时在 old 区头部 如果 old 区的数据页存活超过 1s(innodb_old_blocks_time) ，就把它移动到 young 区young 区的后 3/4 被命中时会被移动到链表头部，前 1/4 被访问了不会进行移动" }, { "title": "软件体系结构", "url": "/posts/%E8%BD%AF%E4%BB%B6%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/", "categories": "计算机, 基础", "tags": "", "date": "2022-06-17 16:03:15 +0800", "snippet": "软件体系结构大纲 绪论 软件体系结构风格 数据流体系结构风格 调用/返回体系结构风格 以数据为中心体系结构风格 虚拟机体系结构风格 事件系统体系结构风格 软件体系结构建模和文档化 质量属性及质量属性策略 可用性及其策略 性能及其策略 可修改性及其策略 安全性及其策略 可测试性及其策略 易用性及其策略 软件体系结构评估绪论软件体系结构定义：软件体系结构 = 组件 + 连接件 + 约束组件为具有某种功能的可重用的软件模块单元，表示了系统中主要的计算单元和数据存储。连接件：表示了组件之间的交互。约束：表示了组件和连接件的拓扑逻辑和约束软件体系结构风格软件体系结构风格定义：描述特定领域中软件系统家族的组织方式的惯用模式，反映了领域中众多系统所共有的结构和语义特性，并指导如何将各个模块和子系统有效 地组织成一个完整的系统。数据流体系结构风格特征： 数据的可用性决定着计算单元是否执行 系统结构由数据在各处理之间的有序移动决定 在纯数据流系统中，处理之间除了数据交换没有任何其他的交互基本构件： 构件接口：输入接口和输出接口 计算模型：从输入端口读数，经过计算/处理，然后写到输出端口连接件： 单向，通常是异步，有缓冲 接口角色：reader和writer 计算模型：把数据从一个处理的输出端口传送到另一个处理的输入端口典型数据流风格： 批处理 管道-过滤器批处理体系结构风格定义： 基本构件：独立的应用程序 连接件：某种类型的媒质 拓扑结构：连接件定义相应的数据流图 每个处理步骤是一个独立的程序 每一步必须在前一步结束后才能开始 数据必须是完整的，以整体的方式传递管道-过滤器体系结构风格构件：过滤器，处理数据流连接件：管道，连接一个源和一个目的过滤器过滤器对数据流的五种变换类型：丰富、精炼、转换、融合、分解无上下文信息，不保留状态，对其他过滤器无任何了解批处理和管道-过滤器的区别批处理： 整体传递数据 构件粒度较大 延迟高，实时性差 无并发管道： 增量传递数据 构件粒度较小 实时性好 可并发调用/返回体系结构风格基本构成： 构件：主程序、子程序 连接器：调用-返回机制 拓扑结构：层次化结构本质：将大系统分解为若干模块，主程序调用这些模块实现完整的功能。主程序/子过程风格对系统进行功能分界，是面向过程编程的主要思路面向对象风格系统被看作对象的集合每个对象都有一个它自己的功能集合。数据及作用在数据上的操作被封装成抽象数据类型（对象）。基本构成： 构件：类和对象 连接件：对象之间通过消息和方法调用实现交互优点： 复用和维护：利用封装和聚合提高生产力 反映现实世界 容易分解一个系统缺点： 管理大量对象：怎样确立大量对象的结构 必须知道对象的身份（对比：在管道/过滤器系统中，一个过滤器无需知道其他过滤器的任何信息） 继承引起复杂度分层风格系统被组织成若干个层次，每个层次由一系列构件组成。下层构件向上层构件提供服务。上层构件被看作是下层构件的客户。分层原则：分离关注、抽象、隐藏。层次之间存在接口，通过接口形成call/return的关系。基本构成： 构件：各层次内部包含的构件 连接件：层间的交互协议 拓扑结构：分层 拓扑约束：对相邻层间交互的约束由上而下的交互模式：外部实体与系统中的最高层交互，最高层使用较低级别层的服务。（请求request）由下而上的交互模式：外部实体与系统中的最底层交互，低层回调高层的服务。（通知notify）优点： 支持基于抽象程度递增的系统设计 局部依赖性：功能的改变通常影响相邻的上下层 可复用性：某独立层保证功能完整性并提供了文档化的接口，便可在多个语境中复用 可替换性：只要服务接口定义不变，同一层的不同实现可以交换使用。 对标准化的支持 可测试性缺点： 并不是每个系统都可以很容易地划分为分层的模式 效率降低：相关数据必须通过一些中间层的若干次转化，才能传到 难以抽象客户机/服务器风格两层C/S结构： 客户程序直接访问数据库，每个客户机都必须安装数据库驱动程序，增加了系统安装和维护工作量。 数据库由众多客户程序直接访问，系统数据完整性与安全性难以维护。 可扩展性较差，功能修改要求在所有客户机重新部署。三层C/S结构：增加了一个应用服务器。应用功能分为表示层、功能层、数据层三层。B/S结构是三层C/S结构的特例。以数据为中心体系结构风格定义：共享数据源以进行数据传递仓库体系结构风格基本构成： 构件：中心数据结构，表示当前数据的状态；一组对中心数据进行操作的独立构件。 连接件：仓库与独立构件之间的交互。两种交互机制：数据库方式、黑板结构。黑板体系结构风格一个大问题被分解为若干个子问题。每个子问题的解决需要不同的问题表达方式和求解模型，分别设计求解程序。黑板结构：中心数据结构的当前状态触发并选择需要执行的过程。基本结构： 黑板：输入/解空间求解状态 知识源：读取/更新黑板，策略知识/求解知识 控制器：监视黑板状态，激活知识源虚拟机体系结构风格解释器解释器是一个用来执行其他程序的程序解释器通常用来在程序语言定义的计算和有效硬件操作确定的计算之间建立对应和联系。基本构件： An interpretation engine（解释器引擎） A Memory that contains： 被解释的源代码 解释器引擎当前的控制状态的表示 程序当前执行状态的表示 连接器：对存储区的数据访问基于规则的系统固定部分与可变部分分离业务逻辑=固定业务逻辑（source code）+可变业务逻辑（rules）+规则引擎核心思想：将业务逻辑中可能频繁发生变化的代码从源代码中分离出来。优点： 降低了修改业务逻辑的成本 缩短了开发时间 将规则外部化，可在多个应用之间共享 对规则的改变将非常迅速并且具有较低的风险事件系统体系风格事件：能够激活对象功能的动作，当发生这种动作后，给涉及的对象发送一个消息，对象可执行相应的功能。隐式调用： 构件不直接调用一个过程 不能假定构件的处理顺序 各个构件之间相互独立。事件系统： 分离的交互：事件源（发布者）不会意识到事件处理器（订阅者）的存在。 一对多通信：一个特定事件可以影响多个事件处理器。 基于事件的触发器：由事件触发过程调用。 异步：支持异步操作。事件源：一个构件可以广播一些事件。事件处理器：构件可以注册自己感兴趣的事件，并将自己的某个过程与相应的事件进行关联。事件管理器：当一个事件被发布，系统自动调用该事件中注册的所有过程。（协调事件源和事件处理器）优点： 可重用性：当需要将一个构件加入现存系统中时，只需将它注册到系统的事件中。 可修改性：当用一个构件代替另一个构建时，不会影响到其他构件的接口。缺点： 构件放弃了对系统计算的控制：一个构件触发一个事件时，不能确定其他构件的响应。事件派遣机制设计无独立调度派遣模块：被观察者/观察者模式有独立调度派遣模块：事件发送给派遣器，派遣器负责接收事件并转发给其他模块。软件体系结构描述方法软件体系结构描述软件体系结构由一定形式的结构化元素组成，即是构件的集合。包括处理构件、数据构件和连接构件。处理构件负责加工数据，数据构件代表被加工的信息，连接构件则负责组合连接不同的构件。软件体系结构建模视图分解视图、使用视图、分层视图、类/泛化视图、进程视图、并发视图、共享数据视图、客户端-服务器视图、部署视图、实施视图、工作分配视图…UML4+1视图：从5个不同的视角包括逻辑视图、进程视图、物理视图、开发视图和场景视图来描述软件体系结构。 用例视图：从外部世界的角度描述系统功能 逻辑视图：描述系统各部分的抽象描述，用于建模系统的组成部分以及各组成部分之间的交互方式 过程视图：描述系统中的进程 开发视图：描述系统的各部分如何被组织为模块和组件 物理视图：描述如何将前三个视图中所述的系统设计实现为一组现实世界的实体。用例图（Use Case）：用于显示若干角色以及这些角色与系统提供的用例之间的连接关系。重要的是记住用例代表了系统的外部视图，因此，不要期望用例与系统内部的类之间存在任何关联。类图、对象图、状态图、协作图、序列图、活动图、包图、组件图、部署图、复合结构、交互概述图、时序图…质量属性及质量属性策略属于非功能性需求质量属性场景的六个组成部分： 刺激源（source）：谁造成的刺激 刺激（stimulus）：一个影响系统的情况 制品（artifact）：系统被影响的部分 环境（environment）：刺激发生时系统所处的状态 响应（response）：刺激所产生的结果 响应衡量指标（response measure）：如何评估响应可用性定义：在要求的外部资源得到保证的前提下，产品在规定的条件下和规定的时刻或时间区间内处于可执行规定功能状态的能力。Availability = MTBF / (MTBF + MTTR)MTBF：Mean Time Between Failure 平均故障间隔时间MTBR：Mean Time Between Repari 平均修复时间当用户使用系统时，系统可用的概率。可用性场景： 刺激源：故障的迹象 刺激：系统出错、崩溃、给出结果不准时、给出错误结果 制品：计算、存储、网络传输 环境：正常状态、亚健康状态 响应：记录日志、通知管理员、关闭系统 响应衡量指标：故障时间百分比、修复故障所需时间、平均无故障时间提升可用性的策略： 故障检测：Heartbeat心跳、Exceptions catch异常捕获 故障恢复：投票、主动冗余（AB完成同样的运算，当A故障时可以快速切换到B）、被动冗余（A完成运算后的一定时间内把自身状态告知B，B再把自身状态更新为A的状态）、内测、检查点/回滚 故障避免：服务下线、事务、进程监控可修改性关注点：修改的成本、哪些部分被修改、修改发生的事件、修改由谁来进行可修改性场景： 刺激源：谁进行的修改 刺激：要进行的具体修改 制品：修改系统的功能、UI 环境：什么时间进行修改 响应：如何修改、测试、部署 响应衡量指标：时间、成本提升可修改性的策略： 限制修改范围（模块高内聚低耦合、考虑可能会发生的修改、让模块通用、隐藏信息、维持接口不见、限制通信路径、使用中介、命名服务器、按需创建实例） 延迟绑定时间：让软件运行期间仍可灵活修改（配置文件、发布-订阅模式、多态）性能关注点：系统响应事件的速度，和事件的数量、到达模式有关性能场景： 刺激源：可能来自系统内部或外部 刺激：事件到来 制品：系统提供的服务 环境：系统所处的状态（正常/紧急/超载） 响应：系统处理到来的事件，可能会导致状态的变化 响应衡量指标：处理事件所花的时间，单位时间内处理事件的数目，处理的错误率/丢失率提升性能的策略： 资源的需求（提高计算效率、减少要处理的数据总量、限制执行时间、限制待处理事件队列长度） 资源的管理（并发、增加可用资源） 资源的仲裁（先来先服务、固定优先级制度、动态优先级）安全性关注点：在保证合法用户使用系统的前提下，抵抗对系统的攻击安全性场景： 刺激源：攻击可能由人或其他系统发起 刺激：对系统的攻击 制品：系统所提供的服务或系统中的数据 环境：系统可能处于不同的情况下（联网/未联网、在线/下线、在防火墙内/外） 响应：合法用户正常使用，拒绝非法用户使用 响应衡量指标：发起攻击的难度，从攻击中恢复的难度提升安全性的策略： 抵抗攻击（用户的证实、用户的授权、维持数据保密性、维持数据完整性、减少暴露、限制访问） 检测攻击 从攻击中恢复可测试性关注点：让软件的bug容易被测试出来，验证功能是否匹配需求，用最小的成本验证软件的质量。可测试性场景： 刺激源：测试可能由不同角色发起 刺激：系统开发到达了里程碑 制品：一个设计、一段代码、整个系统 环境：系统可能处于设计阶段/开发阶段/部署阶段/正常运行时 响应：可以进行测试，并且可以观察到测试结果 响应衡量指标：白盒测试中的覆盖率、未来继续发现bug的概率提升可测试性的策略： 黑盒测试（记录/回放、把接口和实现分离开、提供专用的测试路径） 白盒测试（内部监控）易用性关注点：让用户使用软件的难度降低易用性场景： 刺激源：终端用户 刺激：终端用户希望学习系统的使用、提高系统使用效率、减少出错 制品：整个系统 环境：系统处于运行时或配置时 响应：系统响应用户的要求 响应衡量指标：用户完成任务的时间、出错的次数、满意度、操作的成功率提升易用性的策略： 运行时策略：系统猜测用户要完成的任务（搜索联想）、给用户适当的反馈（提示剩余时间、进度）、支持撤销操作 设计时策略：将用户界面和系统其他部分隔离开（MVC）软件体系结构评估定义：架构评估是软件开发生命周期中一个活动，在此活动中，相关项目干系人使用评估技术，在一个正式或非正式的过程中一起分析软件架构。SAAM要求系统的各种风险承担者列举出若干场景对场景划分优先级更多地关注功能性和可修改性。六个步骤： 场景开发 体系结构描述 场景的分类和优先级的确定 单个场景评估 场景交互评估 形成总体评估ATAM这种方法不仅可以揭示出软件架构对特定质量目标的满足情况，而且能够更清楚地认识到质量属性之间的联系，即如何权衡诸多质量属性。ATAM是SAAM的一个细化，特别关注可修改性、性能、可用性和安全性目标： 不是提供精确的分析，是发现由体系结构决策产生的风险 希望找到趋势：体系结构决策和系统属性预测之间的相关性优点： 确定风险 明确质量属性需求 完善体系结构文档 体系结构决策的文档化基础 加强利益相关者之间的沟通四个阶段： 阶段0：合作与准备 阶段1：初步评估 评估小组对ATAM进行介绍 客户描述系统的功能需求、质量属性需求 设计师介绍技术约束条件，用以满足质量属性的体系结构方法设计 确定核心体系结构方法 通过构建效用树来实别、确定优先级并优化最重要的质量属性目标 评估团队从特定质量属性的角度探索体系结构方法以识别风险 阶段2：完成评估 阶段3：后续工作风险（Risks），非风险（Non-Risks），敏感点（Sensitivities），权衡点（Tradeoffs）： 风险是一个存在潜在问题的体系结构决策 非风险是经分析认为安全的良好体系结构决策 敏感点是影响一个或多个组件（或组件关系）的特性，对于实现特定质量属性响应至关重要。 权衡点是影响多个质量属性的特性，是多个质量属性的敏感点。总结：ATAM是 一种根据多个质量属性评估体系结构的方法 发现体系结构决策后果的有效策略 一种识别趋势的方法，而不是进行精确分析的方法" }, { "title": "算法导论", "url": "/posts/%E7%AE%97%E6%B3%95%E5%AF%BC%E8%AE%BA/", "categories": "计算机, 基础", "tags": "", "date": "2022-06-13 22:01:21 +0800", "snippet": "算法导论插入排序堆排序快速排序随机快速排序线性时间内排序：Counting sort（计数排序），Radix sort（基数排序），Bucket sort（桶排序）分治三个步骤： 分解步骤将问题划分为一些子问题，子问题的形式和原问题一样，只是规模更小 解决步骤递归地求解出子问题，如果子问题的规模足够小，则停止递归，直接求解 合并步骤将子问题的解组合成原问题的解动态规划四个步骤： 刻画一个最优解的结构特征 递归地定义最优解的值 计算最优解的值，通常采用自底向上的方法 利用计算出的信息构造一个最优解主定理求递归时间复杂度\\[T(n)=aT(n/b) + f(n)\\] \\[if \\space f(n)=O(n^{log_{b}{a}-\\epsilon})\\space for \\space some \\space constant \\space \\epsilon&amp;gt;0,then \\space T(n)=\\Theta(n^{log_{b}{a}})\\] \\[if \\space f(n)=\\Theta(n^{log_{b}a}log^{k}n)\\space with \\space k&amp;gt;=0,then \\space T(n)=\\Theta(n^{log_{b}a}log^{k+1}n)\\] \\(if \\space f(n)=\\Omega(n^{log_{b}{a}+\\epsilon})\\space with \\space \\epsilon &amp;gt; 0, and \\space f(n) \\space satisfies \\space the \\space condition, then \\space T(n)=\\Theta(f(n))\\)\\(Regularity \\space condition:af(n/b)&amp;lt;=cf(n)\\space for \\space some \\space constant \\space c &amp;lt; 1 \\space and \\space all \\space sufficiently \\space large \\space n\\)Partition算法求第i小，最坏n2最大子数组和dp[i] 表示以i为最后一项的连续子数组和的最大值dp[0] = arr[0]dp[i] = max(dp[i - 1] + arr[i], arr[i])压缩空间：for (int i = 0; i &amp;lt; n; i++) { if (sum &amp;lt; 0) { sum = arr[i]; } else { sum += arr[i]; } ans = max(ans, sum);}return ans;装配线调度dp1[0] = e1 + a[1][0]dp1[i] = min(dp1[i - 1] + a[1][i], dp2[i - 1] + t[2][i - 1] + a[1][i]) (i &amp;gt;= 1)dp2[0] = e2 + a[2][0]dp2[i] = min(dp2[i - 1] + a[2][i], dp1[i - 1] + t[1][i - 1] + a[2][i]) (i &amp;gt;= 1)矩阵链乘dp[i][j]表示i到j之间的矩阵乘法次数dp[i][j] = 0 (i == j)dp[i][j] = min{dp[i][k] + dp[k + 1][j] + p[i - 1]p[k]p[j]} i &amp;lt;= k &amp;lt;= j (i &amp;lt; j)最长公共子序列dp[i][j]表示x的前i个和y的前j个的最长公共子序列长度for (int i = 1; i &amp;lt; len(x) + 1; i++) { for (int j = 1; j &amp;lt; len(y) + 1; j++) { if x[i - 1] == y[j - 1] { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]; } }}return dp[len(x)][len(y)];最长公共子串dp[i][j]表示以x的第i个字符为结尾，以y的第j个字符为结尾的最长公共子串长度int result = 0;for (int i = 1; i &amp;lt; len(x) + 1; i++) { for (int j = 1; j &amp;lt; len(y) + 1; j++) { if (x[i - 1] == y[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = 0; } result = max(result, dp[i][j]); }}return result;活动选择问题 Activity-selection problem贪心：结束时间升序排列，从前往后能选就选01背包dp[i][j]表示容量为j装前i个物品的最大价值for (int i = 1; i &amp;lt;= weights.size(); i++){ for (int j = capacity; j &amp;gt;= weights[i - 1]; j--) { dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weights[i - 1]] + values[i - 1]); }}return dp[weights.size()][capacity];压缩空间：for (int i = 0; i &amp;lt; weights.size(); i++){ for (int j = capacity; j &amp;gt;= weights[i]; j--) { dp[j] = max(dp[j], dp[j - weights[i]] + values[i]); }}return dp[capacity];分数背包value/weight 降序排序贪心dijkstra O(E+VlgV)Bellman Ford O(VE)Floyd-WarshallJohnson’s algorithm 为每个结点找一个值做dijkstraLC检索 Least Cost Search可计算性：不可判定问题Undecidable ProblemNP完全问题NP-Complete：SAT，3-color，TSP" }, { "title": "Real-Time Rendering 第五章 着色基础（Shading Basics）", "url": "/posts/RTR5/", "categories": "计算机, 图形学", "tags": "", "date": "2021-10-07 22:00:21 +0800", "snippet": "Real-Time Rendering第五章 着色基础渲染三维对象的图像时，模型不仅应具有适当的几何形状，还应具有所需的视觉外观。根据不同的需求，模型的视觉外观可以是真实感外观（外观接近真实物体）或是各种风格化外观。如下图所示，上面的图片是一种真实感外观渲染，下面的图片是一种风格化外观渲染。本章将讨论照片级真实感渲染和风格化渲染的着色基础。着色模型（Shading Models）确认渲染对象外观的第一步是选额着色模型。着色模型用于描述对象应该如何根据对象表面法线、视角方向（view direction）和光照方向等因素来计算其外观（颜色）。举个例子，我们将使用Gooch着色模型的变体。这是非真实感渲染的一种形式。Gooch着色基本思想是将表面法线与光源的位置进行比较。如果法线指向灯光，则使用较暖的色调为表面着色，否则使用较冷的色调。介于两者之间的角度在这些色调之间进行插值，这取决于用户提供的表面颜色。如下图所示：着色模型通常具有用于控制外观变化的属性（properties）。设置这些属性的值是确定对象外观的下一步。我们的示例模型只有一种属性，即表面颜色。我们可以看一下模型本身的数学定义：\\[\\mathbf{c}_{shaded}=s\\mathbf{c}_{highlight}+(1-s)(t\\mathbf{c}_{warm}+(1-t)\\mathbf{c}_{cool})\\]其中：\\(\\mathbf{c}_{cool}=(0,0,0.55)+0.25\\mathbf{c}_{surface}\\)，\\(\\mathbf{c}_{warm}=(0.3,0.3,0)+0.25\\mathbf{c}_{surface}\\)，\\(\\mathbf{c}_{highlight}=(1,1,1)\\)，\\(t=\\frac{(n\\cdot l)+1}{2}\\)，\\(\\mathbf{r}=2(\\mathbf{n}\\cdot\\mathbf{l})\\mathbf{n}-\\mathbf{l}\\)，\\(s=(100(\\mathbf{r}\\cdot\\mathbf{v})-97)^{\\mp}\\)。该定义中的几个数学表达式也经常可以在其他着色模型中找到。着色操作中通常会进行Clamping操作，通常Clamping到0或Clamping在0到1之间。这里的标记是将高光混合因子\\(s\\)Clamping在0到1之间。点积运算符出现3次，每次出现在两个单位长度的向量之间，这是一个非常常见的模式。两个向量的点积是它们的长度与它们之间夹角的余弦的乘积。因此，两个单位长度向量的点积就是余弦，它是两个向量彼此对齐程度的度量。由余弦组成的简单函数通常是最令人愉悦和最准确的数学表达式，用于说明着色模型中两个方向（例如，光照方向和表面法线）之间的关系。另一种常见的着色操作是基于0到1之间的标量值在两种颜色之间线性插值。该操作采用\\(t\\mathbf{c}_a+(1-t)\\mathbf{c}_b\\)的形式，随着\\(t\\)的值在1和0之间移动，它会在\\(\\mathbf{c}_a\\)和\\(\\mathbf{c}_b\\)之间进行插值。此形式在上面的模型中出现了两次，一次是在\\(\\mathbf{c}_{warm}\\)和\\(\\mathbf{c}_{cool}\\)之间插值，第二次在前面的插值结果与\\(\\mathbf{c}_{highlight}\\)之间进行插值。线性插值在着色器中出现的频率很高，以至于在大多数着色语言中，它都是一个内置函数，称为lerp或mix。向量\\(\\mathbf{r}=2(\\mathbf{n}\\cdot\\mathbf{l})\\mathbf{n}-\\mathbf{l}\\)是反射光向量，是光线\\(\\mathbf{l}\\)关于法线\\(\\mathbf{n}\\)的反射光线。尽管不像前两个操作那样常见，但是大多数着色语言也都具有内置的反射（reflect）功能。通过将这些操作以不同的方式与各种数学表达式和着色参数组合在一起，可以为多种风格化和写实的外观定义着色模型。光源（Light Sources）光照对我们上面的示例着色模型的影响非常简单。但是现实世界中的光照可能非常复杂。可以有多个光源，每个光源都有自己的大小、形状、颜色和强度。间接光照会带来更多的变化。相反，根据应用程序和视觉样式的需要，风格化的着色模型可以以多种不同方式使用光照。一些高度风格化的模型可能根本没有光照的概念，或者（例如我们的Gooch着色示例）可能仅使用它来提供一些简单的方向性。其次，着色模型可以以二元方式对光的存在或不存在做出反应。即使用这种着色模型的表面在有光照时具有一种外观，在没有光照时具有另一种外观。区分这两种情况的标准有距光源的距离，阴影，表面是否背对光源（即法线与光线之间的角度大于90度）等因素。进一步，从二元方式到能随光照逐渐变化的着色，可以用简单的插值来实现。例如：\\[\\mathbf{c}_{shaded}=f_{unlit(\\mathbf{n},\\mathbf{v})}+k_{light}f_{lit}(\\mathbf{l},\\mathbf{n},\\mathbf{v})\\]上式可以简单的扩展为RGB光照颜色\\(\\mathbf{c}_{light}\\)：\\[\\mathbf{c}_{shaded}=f_{unlit(\\mathbf{n},\\mathbf{v})}+\\mathbf{c}_{light}f_{lit}(\\mathbf{l},\\mathbf{n},\\mathbf{v})\\]以及多个光源：\\[\\mathbf{c}_{shaded}=f_{unlit(\\mathbf{n},\\mathbf{v})}+\\sum_{i=1}^{n}\\mathbf{c}_{light}f_{lit}(\\mathbf{l_i},\\mathbf{n},\\mathbf{v})\\]我们还可以将光在表面上的效果可视化为一组射线，其中射线击中表面的密度对应用于表面着色的光照强度。如下图所示，该图为光照表面的横截面。沿该截面入射到表面的光线之间的间距与\\(\\mathbf{l}\\)和\\(\\mathbf{n}\\)的夹角的余弦成反比。因此，入射到表面的光线的总密度与\\(\\mathbf{l}\\)和\\(\\mathbf{n}\\)的夹角的余弦成正比，正如我们前面所看到的，它等于这两个单位长度向量之间的点积。在这里，我们看到了为什么光照向量\\(l\\)与光的传播方向相反会很方便，否则我们将在执行点积运算之前将其取反。当光线密度为正时，光线密度与点积成正比。负值对应于从表面后面发出的光线，是无效的。因此，我们需要先 将其Clamp点积为0。使用\\(x^{+}\\)表示，即将负值Clamp为0，我们会得到：\\[\\mathbf{c}_{shaded}=f_{unlit}(\\mathbf{n},\\mathbf{v})+\\sum_{i=1}^{n}(\\mathbf{l}_i\\cdot n)^{+}\\mathbf{c}_{light_i}f_{lit}(\\mathbf{l}_i,\\mathbf{n},\\mathbf{v})\\]对于函数\\(f_{lit}()\\)，最简单的选择是使其为常函数：\\[f_{lit}()=\\mathbf{c}_{surface}\\]代入后即得：\\[\\mathbf{c}_{shaded}=f_{unlit}(\\mathbf{n},\\mathbf{v})+\\sum_{i=1}^{n}(\\mathbf{l}_i\\cdot n)^{+}\\mathbf{c}_{light_i}\\mathbf{c}_{surface}\\]该模型的lit part（即后半部分）对应于兰伯特着色模型（Lambertian shading model），该模型在理想的漫反射表面（即完全无光泽的表面）下运行。接下来，我们将讨论几种流行类型的光源，它们有一个共同点：在给定的表面位置，每个光源仅从一个方向\\(\\mathbf{l}\\)照射表面。即从着色表面的一个点来看，光源是一个无限小的点。但现实世界中的光源并非严格如此，但是大多数光源与被照明表面的距离较小，因此这是一个合理的近似值。 方向光（Directional Lights）方向光（Directional Lights）是光源最简单的一种模型：\\(\\mathbf{l}\\)和\\(\\mathbf{c}_{light}\\)都是恒定的，除了\\(\\mathbf{c}_{light}\\)可能会因阴影而衰减。方向光无位置。当到光源的距离相对于场景大小较大时，方向光具有不错的效果，例如被太阳照亮的场景基本上都可以用方向光。" }, { "title": "Real-Time Rendering 第四章 变换（Transforms）", "url": "/posts/RTR4/", "categories": "计算机, 图形学", "tags": "", "date": "2021-10-06 18:58:15 +0800", "snippet": "Real-Time Rendering第四章 变换变换（Transform）是对点、矢量 、颜色等实体以某种方式进行转换的一种操作。利用变换，你可以对物体、灯光、摄像机进行位移、缩放等操作。变换可分为线性变换和非线性变换。线性变换是一种保留矢量加法和标量乘法的变换。即：$f(x)+f(y)=f(x+y)$$kf(x) = f(kx)$例如，$f(x)=5x$是一种变换，它取一个矢量并将每个元素乘以5。同时他也是一个线性变换，因为他满足上面的两个等式。这个函数是一种缩放变换，因为它更改对象的比例（大小）。旋转变换是另一种围绕原点旋转矢量的线性变换。缩放和旋转变换，实际上是三元素矢量的所有线性变换，可以使用3×3矩阵表示。然而，3×3矩阵具有局限性。现在我们需要平移变换，例如$f(x)=x+(7, 3, 2)$，很显然，平移变换是非线性变换。为了组合线性变换和平移，我们需要使用仿射变换。仿射变换通常存储为4×4矩阵。仿射变换是先执行线性变换，然后执行平移的变换。为了表示四维矢量，我们使用齐次表示法，以相同的方式表示点和方向矢量。一个方向矢量可以表示为$v=(v_x,v_y,v_z,0)^T$，一个点可以表示为$v=(v_x,v_y,v_z,1)^T$。所有平移、旋转、缩放、反射和裁剪矩阵都是仿射矩阵。仿射矩阵的主要特点是它保留了直线的平行性，但不一定保留长度和角度。仿射变换也可以是单个仿射变换的任何串联序列。基础变换（Basic Transforms）下面我们介绍最基本的变换，如平移、旋转、缩放、剪切、复合变换、刚体变换和法线变换。 平移变换从一个位置到另一个位置的变化由平移矩阵$T$表示。这个矩阵可以将一个实体位移$t=(t_x,t_y,t_z)$个单位。$T$矩阵形如：\\[T=\\left[\\matrix{1&amp;amp;0&amp;amp;0&amp;amp;t_x\\\\0&amp;amp;1&amp;amp;0&amp;amp;t_y\\\\0&amp;amp;0&amp;amp;1&amp;amp;t_z\\\\0&amp;amp;0&amp;amp;0&amp;amp;1}\\right]\\]我们可以使用矩阵乘法来表示对一个点进行平移变换：\\[\\left[\\matrix{1&amp;amp;0&amp;amp;0&amp;amp;t_x\\\\0&amp;amp;1&amp;amp;0&amp;amp;t_y\\\\0&amp;amp;0&amp;amp;1&amp;amp;t_z\\\\0&amp;amp;0&amp;amp;0&amp;amp;1}\\right]\\left[\\matrix{x\\\\y\\\\z\\\\1}\\right]=\\left[\\matrix{x+t_x\\\\y+t_y\\\\z+t_z\\\\1}\\right]\\]但如果我们对一个方向矢量进行平移变换：\\[\\left[\\matrix{1&amp;amp;0&amp;amp;0&amp;amp;t_x\\\\0&amp;amp;1&amp;amp;0&amp;amp;t_y\\\\0&amp;amp;0&amp;amp;1&amp;amp;t_z\\\\0&amp;amp;0&amp;amp;0&amp;amp;1}\\right]\\left[\\matrix{x\\\\y\\\\z\\\\0}\\right]=\\left[\\matrix{x\\\\y\\\\z\\\\0}\\right]\\]可以发现，平移变换并不会影响方向矢量。这点很容易理解，因为矢量没有位置属性，所以平移不应该对四维矢量产生影响。平移矩阵的逆矩阵就是反向平移得到的矩阵，即：\\[\\left[\\matrix{1&amp;amp;0&amp;amp;0&amp;amp;-t_x\\\\0&amp;amp;1&amp;amp;0&amp;amp;-t_y\\\\0&amp;amp;0&amp;amp;1&amp;amp;-t_z\\\\0&amp;amp;0&amp;amp;0&amp;amp;1}\\right]\\] 旋转变换：我们知道，旋转操作需要指定一个旋转轴，这个旋转轴不一定是空间中的坐标轴。如果我们需要把点绕着$x$轴旋转$\\theta$度，可以使用下面的矩阵：\\[R_x(\\theta)=\\left[\\matrix{1&amp;amp;0&amp;amp;0&amp;amp;0\\\\0&amp;amp;cos\\theta&amp;amp;-sin\\theta&amp;amp;0\\\\0&amp;amp;sin\\theta&amp;amp;cos\\theta&amp;amp;0\\\\0&amp;amp;0&amp;amp;0&amp;amp;1}\\right]\\]绕$y$轴的旋转：\\[R_y(\\theta)=\\left[\\matrix{cos\\theta&amp;amp;0&amp;amp;sin\\theta&amp;amp;0\\\\0&amp;amp;1&amp;amp;0&amp;amp;0\\\\-sin\\theta&amp;amp;0&amp;amp;cos\\theta&amp;amp;0\\\\0&amp;amp;0&amp;amp;0&amp;amp;1}\\right]\\]绕$z$轴的旋转：\\[R_z(\\theta)=\\left[\\matrix{cos\\theta&amp;amp;-sin\\theta&amp;amp;0&amp;amp;0\\\\sin\\theta&amp;amp;cos\\theta&amp;amp;0&amp;amp;0\\\\0&amp;amp;0&amp;amp;1&amp;amp;0\\\\0&amp;amp;0&amp;amp;0&amp;amp;1}\\right]\\]旋转矩阵的逆矩阵是旋转相反角度得到的变换矩阵。 缩放变换我们可以对一个点沿空间的$x$轴、$y$轴和$z$轴进行缩放。由缩放矩阵$S$表示。$S$矩阵形如：\\[S=\\left[\\matrix{k_x&amp;amp;0&amp;amp;0&amp;amp;0\\\\0&amp;amp;k_y&amp;amp;0&amp;amp;0\\\\0&amp;amp;0&amp;amp;k_z&amp;amp;0\\\\0&amp;amp;0&amp;amp;0&amp;amp;1}\\right]\\]同样，我们可以使用矩阵乘法来表示一个缩放变换：\\[\\left[\\matrix{k_x&amp;amp;0&amp;amp;0&amp;amp;0\\\\0&amp;amp;k_y&amp;amp;0&amp;amp;0\\\\0&amp;amp;0&amp;amp;k_z&amp;amp;0\\\\0&amp;amp;0&amp;amp;0&amp;amp;1}\\right]\\left[\\matrix{x\\\\y\\\\z\\\\1}\\right]=\\left[\\matrix{k_xx\\\\k_yy\\\\k_zz\\\\1}\\right]\\]对方向矢量也可以使用同样的矩阵进行缩放：\\[\\left[\\matrix{k_x&amp;amp;0&amp;amp;0&amp;amp;0\\\\0&amp;amp;k_y&amp;amp;0&amp;amp;0\\\\0&amp;amp;0&amp;amp;k_z&amp;amp;0\\\\0&amp;amp;0&amp;amp;0&amp;amp;1}\\right]\\left[\\matrix{x\\\\y\\\\z\\\\0}\\right]=\\left[\\matrix{k_xx\\\\k_yy\\\\k_zz\\\\0}\\right]\\]缩放矩阵的逆矩阵是使用原缩放系数的倒数来对点或方向矢量进行缩放，即：\\[\\left[\\matrix{1/k_x&amp;amp;0&amp;amp;0&amp;amp;0\\\\0&amp;amp;1/k_y&amp;amp;0&amp;amp;0\\\\0&amp;amp;0&amp;amp;1/k_z&amp;amp;0\\\\0&amp;amp;0&amp;amp;0&amp;amp;1}\\right]\\] 剪切变换剪切变换可以用于扭曲模型，例如方形变为平行四边形，任意一边都可以被拉伸。一共有六种基本剪切矩阵：$H_{xy}(s)$，$H_{xz}(s)$，$H_{yx}(s)$，$H_{yz}(s)$，$H_{zx}(s)$，$H_{zy}(s)$。第一个下标表示哪个坐标将要被变换（剪切），第二个下标表示用哪个坐标来变换（剪切）。例如：\\[H_{xz}(s)=\\left[\\matrix{1&amp;amp;0&amp;amp;s&amp;amp;0\\\\0&amp;amp;1&amp;amp;0&amp;amp;0\\\\0&amp;amp;0&amp;amp;1&amp;amp;0\\\\0&amp;amp;0&amp;amp;0&amp;amp;1}\\right]\\]\\[p=(p_x,p_y,p_z)^T\\]\\[H_{xz}(s)p=\\left[\\matrix{1&amp;amp;0&amp;amp;s&amp;amp;0\\\\0&amp;amp;1&amp;amp;0&amp;amp;0\\\\0&amp;amp;0&amp;amp;1&amp;amp;0\\\\0&amp;amp;0&amp;amp;0&amp;amp;1}\\right]\\left[\\matrix{p_x\\\\p_y\\\\p_z\\\\1}\\right]=\\left[\\matrix{p_x+sp_z\\\\p_y\\\\p_z\\\\1}\\right]\\]剪切矩阵的逆矩阵是沿相反方向的剪切，即：$H_{ij}^{-1}(s)=H_{ij}(-s)$ 复合变换为了提高效率，我们需要将矩阵序列连接成单个矩阵。例如，假设我们有一个具有数百万个顶点的游戏场景，场景中的所有对象都必须缩放、旋转并最终平移。现在，不是将所有顶点与三个矩阵中的每一个相乘，而是将三个矩阵连接成一个矩阵。然后将此单个矩阵应用于顶点。我们可以把平移、旋转和缩放组合起来，来形成一个复杂的变换过程。由于矩阵乘法不满足交换律，矩阵相乘的顺序不同会导致变换的结果不同。例如，我们现在有两个变换矩阵，一个缩放矩阵$S$和一个旋转矩阵$R$，$S(2,0.5,1)$表示将$x$坐标变为$2$倍，将$y$坐标变为$1/2$，$R_z(\\pi/6)$表示沿$z$轴旋转$\\pi/6$，这两个矩阵相乘有两种顺序，$RS$和$SR$，他们实现的变换是不同的：在绝大多数情况下，我们约定变换的顺序就是先缩放，再旋转，最后平移。即复合变换矩阵为：$C=TRS$除了需要注意不同类型的变换顺序外，我们有时还需要小心旋转的变换顺序。如果我们需要同时绕着3个轴进行旋转，是先绕$x$轴、再绕$y$轴最后绕$z$轴旋转还是按其他的旋转顺序呢？首先，我们有两种旋转方法：内旋和外旋。 每次旋转是绕固定轴（一个固定参考系，比如世界坐标系）旋转，称为外旋。 每次旋转是绕自身旋转之后的轴旋转，称为内旋。按照内旋方式，$Z$-$Y$-$X$旋转顺序（指先绕自身轴$Z$，再绕自身轴$Y$，最后绕自身轴$X$），可得旋转矩阵（内旋是右乘）：$R_1=R_z(\\gamma)R_y(\\beta)R_x(\\alpha)$按照外旋方式，$X$-$Y$-$Z$旋转顺序（指先绕固定轴$X$，再绕固定轴$Y$，最后绕固定轴$Z$），可得旋转矩阵（外旋是左乘）：$R_2=R_z(\\gamma)R_y(\\beta)R_x(\\alpha)$两种旋转方法按上面两种不同的顺序旋转结果是相同的。 刚体变换当一个人从桌子上拿起一个实心物体（比如一支笔）并将其移动到另一个位置，例如衬衫口袋，只有物体的方向和位置会改变，而物体的形状通常不会受到影响。这种变换仅由平移和旋转的复合组成，称为刚体变换。刚体变换可以表示为：\\[X=T(t)R=\\left[\\matrix{r_{00}&amp;amp;r_{01}&amp;amp;r_{02}&amp;amp;t_x\\\\r_{10}&amp;amp;r_{11}&amp;amp;r_{12}&amp;amp;t_y\\\\r_{20}&amp;amp;r_{21}&amp;amp;r_{22}&amp;amp;t_z\\\\0&amp;amp;0&amp;amp;0&amp;amp;1}\\right]\\]用途：摄像机LookAt 法线变换一般来说，点和绝大部分方向矢量都可以使用同一个4×4或3×3的变换矩阵把其从坐标空间A变换到坐标空间B中。但在变换法线的时候，如果使用同一个变换矩阵，可能就无法确保维持法线的垂直性。如图：我们先来了解一下另一种方向矢量：切线（tangent），也被称为切矢量（tangent vector）。与法线类似，切线往往也是模型顶点携带的一种信息。它通常与纹理空间对齐，而且与法线方向垂直.由于切线是由两个顶点之间的差值计算得到的，因此我们可以直接使用用于变换顶点的变换矩阵来变换切线。假设，我们使用变换矩阵$M_{A \\rightarrow B}$来变换顶点，可以由下面的式子直接得到变换后的切线：$T_B=M_{A \\rightarrow B}T_A$我们可以由数学约束条件来推出变换法线的矩阵。我们知道同一个顶点的切线$T_{A}$和法线$N_{A}$必须满足垂直条件，即$T_{A} \\cdot N_{A}$。给定变换矩阵$M_{A \\rightarrow B}$，我们已经知道$T_B=M_{A \\rightarrow B}T_A$。我们现在想要找到一个矩阵$G$来变换法线$N_{A}$，使得变换后的法线仍然与切线垂直，即：$T_{B} \\cdot N_{B}=(M_{A \\rightarrow B} \\cdot T_{A}) \\cdot (GN_{A})=0$$(M_{A \\rightarrow B} \\cdot T_{A}) \\cdot (GN_{A})=(M_{A \\rightarrow B} \\cdot T_{A})^T \\cdot (GN_{A})=T_{A}^T(M_{A \\rightarrow B}^TG)N_{A}=0$又$T_{A} \\cdot N_{A}=0$因此如果$M_{A \\rightarrow B}^TG=I$，那么上式成立。即$G=(M_{A \\rightarrow B}^T)^{-1}$。另外，如果变换矩阵$M_{A \\rightarrow B}$为正交矩阵，即变换只包括旋转变换，那么$M_{A \\rightarrow B}^T=M_{A \\rightarrow B}^{-1}$，即$(M_{A \\rightarrow B}^T)^{-1}=M_{A \\rightarrow B}$。特殊的矩阵变换和运算（Special Matrix Transforms and Operations）接下来将介绍对实时渲染至关重要的几种矩阵变换和运算。 欧拉变换这种变换是一种简单的方法，可以构造一个矩阵将实体定向到某个方向。它的名字来自伟大的瑞士数学家莱昂哈德·欧拉（Leonhard Euler）（1707-1783）。首先，我们要确定模型自身的坐标轴。最常见的是朝向沿负$z$轴，头顶沿$y$轴，如图所示。欧拉变换是三个矩阵的乘积，即图中所示的旋转，表示为：$E(h,p,r)=R_z(r)R_x(p)R_y(h)$矩阵相乘可以用24种不同的顺序，其中上面这种是最常用的。其中，$r$代表roll角，沿$z$轴旋转；$p$代表pitch角，沿$x$轴旋转；$h$代表head角，也称为yaw角，沿$y$轴旋转。注意欧拉变换不仅可以用于设置摄像机的朝向，也可以设置任何物体或实体的朝向。这些变换可以在全局的世界坐标系下完成，也可以在相对于某个物体的局部坐标系完成。尽管对于小的角度或者观察者朝向改变，欧拉角很有用，但它也有一些严重的限制。同时结合使用两个欧拉角集合是困难的。例如，在两个欧拉角集合间进行插值不是简单地对两组集合的三个角度分别进行插值。因为两个不同的欧拉角集合可能给出相同的朝向，此时任何插值都不会旋转物体。这些是考虑用四元数（Quaternion）等来代替欧拉角的原因。 从欧拉变换中提取参数有时从欧拉变换矩阵，提取出欧拉角$h$，$p$，$r$是有用的，过程如下：\\[E(h,p,r)=\\left[\\matrix{e_{00}&amp;amp;e_{01}&amp;amp;e_{02}\\\\e_{10}&amp;amp;e_{11}&amp;amp;e_{12}\\\\e_{20}&amp;amp;e_{21}&amp;amp;e_{22}}\\right]=R_z(r)R_x(p)R_y(h)\\]连接三个旋转矩阵后得到：\\[E=\\left[\\matrix{\\cos r \\cos h - \\sin r \\sin p \\sin h &amp;amp; - \\sin r \\cos p &amp;amp; \\cos r \\sin h + \\sin r \\sin p \\cos h\\\\ \\sin r \\cos h + \\cos r \\sin p &amp;amp; \\sin h \\cos r &amp;amp; \\cos p \\sin r \\sin h - \\cos r \\sin p \\cos h\\\\ \\cos p \\sin h&amp;amp; \\sin p &amp;amp; \\cos p \\cos h}\\right]\\]显然，$\\sin p = e_{21}$，且：$\\frac{e_{01}}{e_{11}}=\\frac{-\\sin r}{\\cos r}=-\\tan r$$\\frac{e_{20}}{e_{22}}=\\frac{-\\sin h}{\\cos h}=-\\tan h$因此可解出三个欧拉角分别为：$h=atan2(-e_{20},e_{22})$$p=arcsin(-e_{21})$$r=atan2(-e_{01},e_{11})$有一个特殊的情形需要处理。如果$\\cos p=0$，则会出现万向节锁（gimbal lock），旋转角度$r,h$将会绕相同的轴旋转（可能方向相反，这取决于$p$的值为$-\\pi/2$还是$\\pi/2$），这样只有一个角度（$r,h$中的一个）需要推导。如果我们任意地设$h=0$，则\\[E=\\left[\\matrix{\\cos r &amp;amp; - \\sin r \\cos p &amp;amp; \\sin r \\sin p \\\\ \\sin r &amp;amp; \\cos r \\cos p &amp;amp; - \\cos r \\sin p \\\\ 0&amp;amp; \\sin p &amp;amp; \\cos p}\\right]\\]因为$p$不影响第一列，所以当$\\cos p=0$时，我们可以使用$\\sin r / \\cos r = \\tan r = e_{10}/e_{00}$，可以得到：$r=atan2(e_{10},e_{00})$注意$\\arcsin$的定义域为$[-\\pi / 2, \\pi / 2]$，这意味着如果$E$创建时包含了一个在此定义域范围外的$p$，则不能提取出原始参数。即：不同的$h,p,r$组合可能产生相同的欧拉变换。当使用欧拉变换时，万向锁（gimbal lock）可能会出现。当某个旋转使得三个自由度(对应$r,p,h$或者说对应$x,y,z$轴)中的一个消失时，万向锁会出现。例如，变换顺序为$xyz$，假设第一个旋转变换为绕$y$轴旋转$\\pi/2$，然后再进行第二个旋转变换。但第一个旋转变换已经导致$z$轴和原始的$x$轴对齐，这样最后绕$z$轴的旋转就是冗余的了。四元数（Quaternion）四元数最早于1843年由Sir William Rowan Hamilton发明，作为复数(complex numbers)的扩展。直到1985年才由Shoemake把四元数引入到计算机图形学中。四元数在一些方面优于Euler angles(欧拉角)和matrices。任意一个三维空间中的定向都可以被表示为一个绕某个特定轴的旋转。给定旋转轴及旋转角度，很容易把其它形式的旋转表示转化为四元数或者从四元数转化为其它形式。四元数可以用于稳定的旋转插值，而这些在欧拉角中是很难实现的。一个复数具有实部和虚部，每一部分由两个实数表示，其中第一个实数要乘以$\\sqrt{-1}$。相似地，四元数由四部分组成，一个实部，三个虚部。三个虚部与旋转轴密切相关，而旋转角度影响四个部分。这里用向量来表示四元数，但是为了和普通矢量进行区分，我们在其上加了个“帽子”: $\\hat{\\mathbf{q}}$。接下来先介绍四元数的基本数学运算，再描述四元数用于旋转等。 数学背景 四元数定义： 一个四元数$\\hat{\\mathbf{q}}$可以被定义以下形式：$\\hat{\\mathbf{q}}=(\\hat{\\mathbf{q_v}},\\hat{\\mathbf{q_w}})=iq_x+jq_y+kq_z+q_w=\\hat{\\mathbf{q_v}}+\\hat{\\mathbf{q_w}}$其中，$\\hat{\\mathbf{q_v}}=iq_x+jq_y+kq_z=(q_x,q_y,q_z)$$i^2=j^2=k^2=-1$，$jk=-kj=i$，$ki=-ik=j$，$ij=-ji=k$$q_w$为四元数的实部，$\\mathbf{q}_v$是虚部，$i,j,k$为虚数单位。对于虚部$\\mathbf{q}_v$，我们可以施加所有普通矢量运算操作，例如加法、缩放、点乘、叉积等。根据四元数的定义，可以推导出两个四元数$\\hat{\\mathbf{q}}$和$\\hat{\\mathbf{r}}$间的乘法运算。注意，虚数单位之间的乘法不满足交换律。 乘法： $\\hat{\\mathbf{q}}\\hat{\\mathbf{r}}=(iq_x+jq_y+kq_z+q_w)(ir_x+jr_y+kr_z+r_w)$$=i(q_yr_z-q_zr_y+r_wq_x+q_wr_x)$$+j(q_zr_x-q_xr_z+r_wq_y+q_wr_y)$$+k(q_xr_y-q_yr_x+r_wq_z+q_wr_z)$$+q_wr_w-q_xr_x-q_yr_y-q_zr_z$$=(\\hat{\\mathbf{q_v}}\\times\\hat{\\mathbf{r_v}}+r_w\\hat{\\mathbf{q_v}}+q_w\\hat{\\mathbf{r_v}},q_wr_w-\\hat{\\mathbf{q_v}}\\cdot\\hat{\\mathbf{r_v}})$ 加法： $\\hat{\\mathbf{q}}+\\hat{\\mathbf{r}}=(\\hat{\\mathbf{q_v}}+\\hat{\\mathbf{r_v}},q_w+r_w)$ 共轭： $\\hat{\\mathbf{q}}^\\ast=(-\\hat{\\mathbf{q_v}},q_w)$ 模： $n(\\hat{\\mathbf{q}})=\\sqrt{\\hat{\\mathbf{q}}\\hat{\\mathbf{q}}^\\ast}=\\sqrt{\\hat{\\mathbf{q}}\\ast\\hat{\\mathbf{q}}}=\\sqrt{\\hat{\\mathbf{q_v}}\\cdot\\hat{\\mathbf{q_v}}+q_w^2}=\\sqrt{q_x^2+q_y^2+q_z^2+q_w^2}$ $\\hat{\\mathbf{i}}=(\\mathbf{0},1)$ 四元数的逆： $\\hat{\\mathbf{q}}^{-1}\\hat{\\mathbf{q}}=\\hat{\\mathbf{q}}\\hat{\\mathbf{q}}^{-1}=1$$n(\\hat{\\mathbf{q}})^2=\\hat{\\mathbf{q}}\\hat{\\mathbf{q}}^\\ast\\Leftrightarrow\\frac{\\hat{\\mathbf{q}}\\hat{\\mathbf{q}}^\\ast}{n(\\hat{\\mathbf{q}})^2}=1$所以四元数的逆为：$\\hat{\\mathbf{q}}^{-1}=\\frac{1}{n(\\hat{\\mathbf{q}})^2}\\hat{\\mathbf{q}}^\\ast$ 四元数的一些规则： 共轭规则：$(\\hat{\\mathbf{q}}^\\ast)^\\ast=\\hat{\\mathbf{q}}$$(\\hat{\\mathbf{q}}+\\hat{\\mathbf{r}})^\\ast=\\hat{\\mathbf{q}}^\\ast+\\hat{\\mathbf{r}}^\\ast$$(\\hat{\\mathbf{q}}\\hat{\\mathbf{r}})^\\ast=\\hat{\\mathbf{r}}^\\ast\\hat{\\mathbf{q}}^\\ast$ 一个四元数的共轭的共轭是该四元数本身。 两个四元数的和的共轭是它们共轭的和。 两个四元数乘积的共轭是它们共轭调换顺序后的乘积。 模规则：$n(\\hat{\\mathbf{q}}\\hat{\\mathbf{r}})=n(\\hat{\\mathbf{q}})n(\\hat{\\mathbf{r}})$ 一个四元数的模等于其共轭的模。 两个四元数乘积的模等于它们模的乘积。 乘法规则：$\\hat{\\mathbf{p}}(s\\hat{\\mathbf{q}}+t\\hat{\\mathbf{r}})=s\\hat{\\mathbf{p}}\\hat{\\mathbf{q}}+t\\hat{\\mathbf{p}}\\hat{\\mathbf{r}}$$(s\\hat{\\mathbf{p}}+t\\hat{\\mathbf{q}})\\hat{\\mathbf{r}}=s\\hat{\\mathbf{p}}\\hat{\\mathbf{r}}+t\\hat{\\mathbf{q}}\\hat{\\mathbf{r}}$$\\hat{\\mathbf{p}}(\\hat{\\mathbf{q}}\\hat{\\mathbf{r}})=(\\hat{\\mathbf{p}}\\hat{\\mathbf{q}})\\hat{\\mathbf{r}}$ 单位四元数： 模为1的四元数为单位四元数。可推导出单位四元数$\\hat{\\mathbf{q}}$可以写作：\\[\\hat{\\mathbf{q}}=(\\sin\\phi\\mathbf{u}_q,\\cos\\phi)=\\sin\\phi\\mathbf{u}_q+\\cos\\phi\\]其中\\(\\mathbf{u}_{q}\\)是一个三维向量，且$\\vert\\vert\\mathbf{u}_{q}\\vert\\vert=1$。因为当且仅当\\(\\vert\\vert\\mathbf{u}_{q}\\vert\\vert=1\\)时，\\[n(\\hat{\\mathbf{q}})=n(\\sin\\phi\\mathbf{u}_q,\\cos\\phi)=\\sqrt{\\sin^2\\phi(\\mathbf{u}_q\\cdot\\mathbf{u}_q)+\\cos^2\\phi}=\\sqrt{\\sin^2\\phi+\\cos^2\\phi}=1\\]对于复数，一个二维单位向量可以写作$\\cos\\phi+i\\sin\\phi=e^{i\\phi}$，对于四元数，等价的有：$\\hat{\\mathbf{q}}=\\sin\\phi\\mathbf{u}_q+\\cos\\phi=e^{\\phi\\mathbf{u}_q}$ 四元数对数和指数函数： $\\log(\\hat{\\mathbf{q}})=\\log(e^{\\phi\\mathbf{u}_q})=\\phi\\mathbf{u}_q$$\\hat{\\mathbf{q}}^t=(\\sin\\phi\\mathbf{u}_q+\\cos\\phi)^t=e^{\\phi t \\mathbf{u}_q}=\\sin(\\phi t)\\mathbf{u}_q+\\cos(\\phi t)$ 四元数变换 用四元数表示旋转： 单位四元数可以以简单的方式表示任何三维旋转。如图为单位四元数表示的旋转：首先，把一个点或向量$\\mathbf{p}=(p_x,p_y,p_z,p_w)^{T}$的四个坐标分别放进一个四元数$\\hat{\\mathbf{p}}$的各个分量中，假设我们有一个单位四元数$\\hat{\\mathbf{q}}=(\\sin\\phi\\mathbf{u}_q,\\cos\\phi)$，可以证明：$\\hat{\\mathbf{q}}\\hat{\\mathbf{p}}\\hat{\\mathbf{q}}^{-1}$会使点$\\hat{\\mathbf{p}}$绕轴$\\mathbf{u}_p$旋转$2\\phi$弧度，如上图所示。注意因为$\\hat{\\mathbf{q}}$是单位四元数，则$\\hat{\\mathbf{q}}^{-1}=\\hat{\\mathbf{q}}^\\ast$。 注意：任何$\\hat{\\mathbf{q}}$的非零实数倍都和$\\hat{\\mathbf{q}}$表示相同的旋转变换。也就是说，$\\hat{\\mathbf{q}}$和$-\\hat{\\mathbf{q}}$表示的也是相同的旋转，这是因为我们同时对旋转轴$\\mathbf{u}_p$和实部$q_w$取负。这也意味着从一个矩阵中提取的四元数可能是$\\hat{\\mathbf{q}}$或$-\\hat{\\mathbf{q}}$。 两个四元数的连接： 给定两个四元数$\\hat{\\mathbf{q}}$和$\\hat{\\mathbf{r}}$（表示两个旋转变换），要实现它们的连接，即先进行$\\hat{\\mathbf{q}}$的变换，再进行$\\hat{\\mathbf{r}}$的变换，四元数点$\\hat{\\mathbf{p}}$是被旋转的对象，则对应的方程为：$\\hat{\\mathbf{r}}(\\hat{\\mathbf{q}}\\hat{\\mathbf{p}}\\hat{\\mathbf{q}}^\\ast)\\hat{\\mathbf{r}}^\\ast=(\\hat{\\mathbf{r}}\\hat{\\mathbf{q}})\\hat{\\mathbf{p}}(\\hat{\\mathbf{r}}\\hat{\\mathbf{q}})^\\ast=\\hat{\\mathbf{c}}\\hat{\\mathbf{p}}\\hat{\\mathbf{c}}^\\ast$这里的$\\hat{\\mathbf{c}}=\\hat{\\mathbf{r}}\\hat{\\mathbf{q}}$是单位四元数，表示两个四元数的连接，即两个旋转变换的连接。 矩阵和四元数的相互转换 很多时候我们需要结合多个变换，而它们中大部分是矩阵形式。我们需要一种方法把方程$\\hat{\\mathbf{q}}\\hat{\\mathbf{p}}\\hat{\\mathbf{q}}^{-1}$转换为矩阵。一个四元数$\\hat{\\mathbf{q}}$可以被转换为一个矩阵$\\mathbf{M}^q$：\\[\\mathbf{M}^q=\\left[\\matrix{1-s(q_y^2+q_z^2) &amp;amp; s(q_xq_y-q_wq_z) &amp;amp; s(q_xq_z+q_wq_y) &amp;amp; 0 \\\\s(q_xq_y+q_wq_z) &amp;amp; 1-s(q_x^2+q_z^2) &amp;amp; s(q_yq_z-q_wq_x) &amp;amp; 0 \\\\s(q_xq_z-q_wq_y) &amp;amp; s(q_yq_z+q_wq_x) &amp;amp; 1-s(q_x^2+q_y^2) &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1}\\right]\\]这里，$s=2/(n(\\hat{\\mathbf{q}}))^2$。对于单位四元数，上面方程可简化为：\\[\\mathbf{M}^q=\\left[\\matrix{1-2(q_y^2+q_z^2) &amp;amp; 2(q_xq_y-q_wq_z) &amp;amp; 2(q_xq_z+q_wq_y) &amp;amp; 0 \\\\2(q_xq_y+q_wq_z) &amp;amp; 1-2(q_x^2+q_z^2) &amp;amp; 2(q_yq_z-q_wq_x) &amp;amp; 0 \\\\2(q_xq_z-q_wq_y) &amp;amp; 2(q_yq_z+q_wq_x) &amp;amp; 1-2(q_x^2+q_y^2) &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1}\\right]\\]一旦构建好四元数，就不需要计算三角函数了。因此这个变换过程是很高效的。把矩阵转换为四元数稍微复杂，且不太常用，此处不做记录。 球面线性插值给定两个单位四元数$\\hat{\\mathbf{q}}$和$\\hat{\\mathbf{r}}$以及一个参数$t\\in[0,1]$，插值得到一个新的四元数。这个操作的代数形式被表达为一个复合四元数$\\hat{\\mathbf{s}}$：$\\hat{\\mathbf{s}}(\\hat{\\mathbf{q}},\\hat{\\mathbf{r}},t)=(\\hat{\\mathbf{r}}\\hat{\\mathbf{q}}^{-1})^t\\hat{\\mathbf{q}}$然而为了软件实现，下面的形式更合适：$\\hat{\\mathbf{s}}(\\hat{\\mathbf{q}},\\hat{\\mathbf{r}},t)=slerp(\\hat{\\mathbf{q}},\\hat{\\mathbf{r}},t)=\\frac{\\sin(\\phi(1-t))}{\\sin\\phi}\\hat{\\mathbf{q}}+\\frac{\\sin(\\phi t)}{\\sin\\phi}\\hat{\\mathbf{r}}$其中，$\\cos\\phi=q_xr_x+q_yr_y+q_zr_z+q_wr_w$slerp函数插值得到的一系列四元数一起组成了一个四维单位球上从$\\hat{\\mathbf{q}}(t=0)$到$\\hat{\\mathbf{r}}(t=1)$的最短弧。这个最短弧位于一个圆上，而这个圆是由$\\hat{\\mathbf{q}}$，$\\hat{\\mathbf{r}}$以及原点组成的平面与这个四维单位球的交集构成。计算得到的旋转四元数绕固定的轴以恒定的速度旋转。slerp函数非常适合在两个方向（orientatiosns）间进行插值，并且表现得很好(固定的轴，恒定的速度)。当多于两个方向时，比如说由n个四元数\\(\\hat{\\mathbf{q}}_0\\)到\\(\\hat{\\mathbf{q}}_{n-1}\\)，我们想要从\\(\\hat{\\mathbf{q}}_0\\)插值到\\(\\hat{\\mathbf{q}}_1\\)，再插值到\\(\\hat{\\mathbf{q}}_2\\)，直到\\(\\hat{\\mathbf{q}}_{n-1}\\)，可以简单直接地使用slerp函数，但这样插值多点四元数会造成不连续的变化，如图所示：可以看到$\\hat{\\mathbf{q}}_2$到$\\hat{\\mathbf{q}}_3$处有一个明显的拐角，得到了不够光滑的曲线。一个更好的方法是使用样条曲线插值（spline）。在\\(\\hat{\\mathbf{q}}_{i}\\)和\\(\\hat{\\mathbf{q}}_{i+1}\\)之间引入\\(\\hat{\\mathbf{a}}_i\\)和\\(\\hat{\\mathbf{a}}_{i+1}\\)。球面三次插值可定义在\\(\\hat{\\mathbf{q}}_i\\)，\\(\\hat{\\mathbf{a}}_i\\)，\\(\\hat{\\mathbf{a}}_{i+1}\\)，\\(\\hat{\\mathbf{q}}_{i+1}\\)，上面。引入的这两个四元数可以这样计算：\\[\\hat{\\mathbf{a}}_i=\\hat{\\mathbf{q}}_i\\exp\\{-[\\log(\\hat{\\mathbf{q}}_i^{-1}\\hat{\\mathbf{q}}_{i-1})+\\log({\\hat{\\mathbf{q}}_i^{-1}\\hat{\\mathbf{q}}_{i+1}})]/4\\}\\]\\[squad(\\hat{\\mathbf{q}}_i,\\hat{\\mathbf{q}}_{i+1},\\hat{\\mathbf{a}}_i,\\hat{\\mathbf{a}}_{i+1},t)=slerp(slerp(\\hat{\\mathbf{q}}_i,\\hat{\\mathbf{q}}_{i+1},t),slerp(\\hat{\\mathbf{a}}_i,\\hat{\\mathbf{a}}_{i+1},t),2t(1-t))\\]可以看到squad函数是由重复使用球形插值slerp得到的。 从一个向量旋转到另一个向量从一个向量$\\mathbf{s}$旋转到另一个向量$\\mathbf{t}$也是一种常见的操作。四元数极大简化了这一过程。首先我们把$\\mathbf{s}$和$\\mathbf{t}$归一化，然后计算单位旋转轴$\\mathbf{u}=(\\mathbf{s}\\times\\mathbf{t})/\\vert\\vert(\\mathbf{s}\\times\\mathbf{t})\\vert\\vert$，然后$e=\\mathbf{s}\\cdot\\mathbf{t}=\\cos(2\\phi)$，并且$\\vert\\vert(\\mathbf{s}\\times\\mathbf{t})\\vert\\vert=\\sin(2\\phi)$，此处$2\\phi$是$\\mathbf{s}$和$\\mathbf{t}$之间的夹角。则表示$\\mathbf{s}$旋转到$\\mathbf{t}$的四元数为：$\\hat{\\mathbf{q}}=(\\sin\\phi \\mathbf{u},\\cos\\phi)$$=(\\frac{1}{\\sqrt{2(1+e)}}(\\mathbf{s}\\times\\mathbf{t}),\\frac{\\sqrt{2(1+e)}}{2})$但是，当$\\mathbf{s}$和$\\mathbf{t}$指向相反的方向时，上面的公式会有除以0的情况出现，即$e=\\cos(2\\phi)=-1$。当出现这种情况时，任意垂直于$\\mathbf{s}$的旋转轴都可以用于旋转到$\\mathbf{t}$。有时我们也需要从$\\mathbf{s}$旋转到$\\mathbf{t}$的矩阵表示：\\[\\mathbf{R}(\\mathbf{s},\\mathbf{t})=\\left[\\matrix{e+hv_x^2 &amp;amp; hv_xv_y-v_z &amp;amp; hv_xv_z+v_y &amp;amp; 0 \\\\hv_xv_y+v_z &amp;amp; e+hv_y^2 &amp;amp; hv_yv_z-v_x &amp;amp; 0 \\\\hv_xv_z-v_y &amp;amp; hv_yv_z+v_x &amp;amp; e+hv_z^2 &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1}\\right]\\]其中，$\\mathbf{v}=\\mathbf{s}\\times\\mathbf{t}$，$e=\\cos(2\\phi)=\\mathbf{s}\\cdot\\mathbf{t}$，$h=\\frac{1-\\cos(2\\phi)}{\\sin^2(2\\phi)}=\\frac{1-e}{\\mathbf{v}\\cdot\\mathbf{v}}=\\frac{1}{1+e}$（当$\\phi\\neq0$且$\\phi\\neq\\pi$时）。当$\\mathbf{s}$和$\\mathbf{t}$平行或几乎平行时，因为$\\vert\\vert\\mathbf{s}\\times\\mathbf{t}\\vert\\vert\\approx 0$，所以无法计算$h$。如果$\\phi\\approx 0$，我们可以直接返回单位矩阵；而如果$\\phi\\approx\\pi$，则绕任意轴旋转$\\pi$弧度，这个轴可以通过求$\\mathbf{s}$和任意不平行于$\\mathbf{s}$的向量的叉积得到。投影（Projections）在实际渲染场景之前，场景中的所有相关对象必须投影到某种平面或某种简单体积上。然后，执行裁剪和渲染。我们前面的变换都没有影响第四个坐标，即w分量。也就是说，点和向量在变换后保留了它们的类型。而且，前面变换矩阵的最后一行都是（0 0 0 1）。下面，我们假设观看者沿着摄像机的负$z$轴观看，$y$轴向上，$x$轴向右，即右手坐标系，这和Unity采用的方案。而DirectX使用左手坐标系，观察者沿相机的正$z$轴观看。这两种方法都是可行的，最终都能达到同样的效果。 正交投影（Orthographic Projection）正交投影的一个特点是投影后平行线保持平行。当使用正交投影查看场景时，无论与摄影机的距离如何，对象都保持相同的大小。矩阵$\\mathbf{P}_o$（如下所示）是一个简单的正交投影矩阵，它保持点的$x$和$y$分量不变，同时将$z$分量设置为零，即正交投影到平面$z=0$上：\\[\\mathbf{P}_o=\\left[\\matrix{1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1}\\right]\\]该投影矩阵的效果如下图所示。很显然，$\\mathbf{P}_o$是不可逆的，因为它的行列式$\\vert\\mathbf{P}_o\\vert=0$。换句话说，这个变换把点从三维降到了二维，而且是不可逆的。使用这种正交投影的一个问题是，它将$z$值为正值的点和$z$值为负值的点都投影到了投影平面上。但是我们通常需要将$z$值（包括$x$值和$y$值）限制在一定的范围内，例如从$n$（近平面）到$f$（远平面）。更为常用的正交投影矩阵由六元组$(l,r,b,t,n,f)$表示，表示左、右、下、上、近和远平面。该矩阵缩放并将这些平面形成的轴对齐边界框（AABB）转换为以原点为中心的轴对齐立方体。AABB的最小角为$(l,b,n)$，最大角为$(r,t,f)$。而且，我们需要$n&amp;gt;f$，因为我们在这个空间中是沿着负$z$轴观看的。在OpenGL中，轴对齐立方体的最小角为$(−1,−1,−1)$ 最大转角为$(1,1,1)$；在DirectX中，最小角为$(−1,−1,0)$ 最大转角为$(1,1,1)$。这个空间被称为规则观察体（canonical view volume），这个空间里的坐标被称为归一化的设备坐标（normalized device coordinates，简称为NDC）。转换为规则观察体是为了更方便地进行裁剪。转换到规则观察体后，再根据该立方体剪裁要渲染的几何体的顶点，最后这些顶点再通过单位正方形映射到屏幕来进行渲染。此正交变换矩阵如下所示：\\[\\mathbf{P}_o=\\mathbf{S(\\mathbf{s})\\mathbf{T(\\mathbf{t})}}=\\left[\\matrix{\\frac{2}{r-l} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; \\frac{2}{t-b} &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; \\frac{2}{f-n} &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1}\\right]\\left[\\matrix{1 &amp;amp; 0 &amp;amp; 0 &amp;amp; -\\frac{l+r}{2} \\\\0 &amp;amp; 1 &amp;amp; 0 &amp;amp; -\\frac{t+b}{2} \\\\0 &amp;amp; 0 &amp;amp; 1 &amp;amp; -\\frac{f+n}{2} \\\\0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1}\\right]\\]\\[=\\left[\\matrix{\\frac{2}{r-l} &amp;amp; 0 &amp;amp; 0 &amp;amp; -\\frac{r+l}{r-l} \\\\0 &amp;amp; \\frac{2}{t-b} &amp;amp; 0 &amp;amp; -\\frac{t+b}{t-b} \\\\0 &amp;amp; 0 &amp;amp; \\frac{2}{f-n} &amp;amp; -\\frac{f+n}{f-n} \\\\0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1}\\right]\\]在计算机图形学中，投影后的空间通常为左手坐标系。因为我们定义AABB的远值小于近值，所以正交投影变换将会导致镜像变换。假设定义的AABB与规则观察体大小相同，即$(l,b,n)$对应$(-1,-1,1)$，$(r,t,f)$对应$(1,1,-1)$，那么正交投影矩阵将变成：\\[\\mathbf{P}_o=\\left[\\matrix{1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; -1 &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1}\\right]\\]这是一个镜像矩阵，这会将右手观察坐标变换为左手标准化设备坐标。DirectX将$z$深度映射到范围$[0,1]$，OpenGL为$[−1,1]$。 这可以通过在正交矩阵之后应用简单的缩放和平移矩阵来实现，即：\\[\\mathbf{M}_{st}=\\left[\\matrix{1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 0.5 &amp;amp; 0.5 \\\\0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1}\\right]\\]所以，在DirectX中的正交投影矩阵为：\\[\\mathbf{P}_{o[0,1]}=\\left[\\matrix{\\frac{2}{r-l} &amp;amp; 0 &amp;amp; 0 &amp;amp; -\\frac{r+l}{r-l} \\\\0 &amp;amp; \\frac{2}{t-b} &amp;amp; 0 &amp;amp; -\\frac{t+b}{t-b} \\\\0 &amp;amp; 0 &amp;amp; \\frac{1}{f-n} &amp;amp; -\\frac{n}{f-n} \\\\0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1}\\right]\\] 透视投影（Perspective Projection）透视投影比正交投影更复杂，它通常用于大多数计算机图形学应用中。透视投影后的平行线通常不平行；相反，它们可能在其极限处收敛到一个点。透视投影更接近于我们的人眼观看世界的感觉，也就是说，距离越远的物体越小。首先，我们给定投影平面$z=-d,d&amp;gt;0$，假设摄影机位于原点，并且我们希望将点$p$投影到平面$z=−d,d&amp;gt;0$，产生一个新的点$q=(qx,qy,−d)$ 。该场景如图所示。从该图中所示的相似三角形中，我们可以得到$q$的$x$分量：$\\frac{q_x}{p_x}=\\frac{-d}{p_z}\\Leftrightarrow q_x=-d\\frac{p_x}{p_z}$。同样，我们也可以得到$q$的$y$分量：$q_y=-d\\frac{p_y}{p_z}$。因此我们可以得到透视投影矩阵$\\mathbf{P}_p$：\\[\\mathbf{P}_p=\\left[\\matrix{1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; -1/d &amp;amp; 0}\\right]\\]下面来看看这个矩阵的效果：\\[\\mathbf{q}=\\mathbf{P}_p\\mathbf{p}=\\left[\\matrix{1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; -1/d &amp;amp; 0}\\right]\\left[\\matrix{p_x\\\\p_y\\\\p_z\\\\1}\\right]=\\left[\\matrix{p_x\\\\p_y\\\\p_z\\\\-p_z/d}\\right]\\Rightarrow\\left[\\matrix{-dp_x/p_z\\\\-dp_y/p_z\\\\-d\\\\1}\\right]\\]其中，最后一步是齐次除法（也叫透视除法），就是把齐次坐标的$x,y,z$分量分别除以$w$分量，因为我们始终约定将点$(p_x,p_y,p_z)$投影到平面$w=1$上。可以看到，变换后的点的$x,y,z$分量与我们上面计算到的结果相同。和正交变换一样，还有一种透视变换是将视锥体（view frustum）转换为前面描述的规则观察体（canonical view volume）。我们假设视锥体从$z=n$开始，在$z=f$结束，$0&amp;gt;n&amp;gt;f$。$z=n$处的矩形在$(l,b,n)$处具有最小角点，在$(r,t,n)$处具有最大角点，如下图所示：参数$(l,r,b,t,n,f)$确定摄像机的视锥体，$l,r$确定水平视野（horizontal field of view），$t,b$确定垂直视野（vertical field of view）。视野越大，摄像机观察到的越多。视野（field of view，简称FOV）是提供场景感的一个重要因素。我们人眼本身就有一个视野。请看下面的式子：$\\phi=2\\arctan(w/(2d))$其中，$\\phi$表示FOV，$w$表示垂直于摄像机视线的物体宽度，$d$表示物体到摄像机的距离。简单来说，$\\phi$就是摄像机能够看到的左右两侧的角度。设置更小的FOV会减少透视效果。设置更大的FOV会使物体看起来扭曲（例如广角相机镜头），特别是靠近屏幕边缘，并会夸大附近物体的比例。然而，更广阔的视野给观众一种物体更大、更令人印象深刻的感觉，并具有给用户更多关于周围环境的信息的优势。将视锥体转换为单位立方体的透视变换矩阵如下所示：\\[\\mathbf{P}_p=\\left[\\matrix{\\frac{2n}{r-l} &amp;amp; 0 &amp;amp; -\\frac{r+l}{r-l} &amp;amp; 0 \\\\0 &amp;amp; \\frac{2n}{t-b} &amp;amp; -\\frac{t+b}{t-b} &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; \\frac{f+n}{f-n} &amp;amp; -\\frac{2fn}{f-n} \\\\0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0}\\right]\\]将这个变换应用到一个点后，我们将得到另一个点$\\mathbf{q}=(q_x,q_y,q_z,q_w)^T$。其中$w$分量通常不为0或1。为了得到正确的投影点，我们还要进行齐次除法：$\\mathbf{q}=(q_x/q_w,q_y/q_w,q_z/q_w,1)^T$矩阵$\\mathbf{P}_p$会将$z=f$的点映射到$+1$，$z=n$的点映射到$-1$。远平面之外的物体将被裁剪，因此不会出现在场景中。但是透视投影也可以处理无限远的平面，我们只要将$f\\rightarrow\\infty$，此时矩阵变为：\\[\\mathbf{P}_p=\\left[\\matrix{\\frac{2n}{r-l} &amp;amp; 0 &amp;amp; -\\frac{r+l}{r-l} &amp;amp; 0 \\\\0 &amp;amp; \\frac{2n}{t-b} &amp;amp; -\\frac{t+b}{t-b} &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; 1 &amp;amp; -2n \\\\0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0}\\right]\\]总结：在应用透视变换矩阵$\\mathbf{P}_p$后，再通过裁剪和齐次除法，我们就能得到归一化的设备坐标（NDC），在上面的矩阵中，$n$和$f$值都为负数，但为了方便用户使用，我们通常还要将它们转换为正数，即$0&amp;lt;n’&amp;lt;f’$。要得到OpenGL中的透视变换矩阵，我们还要进行一次镜像变换，即乘上$\\mathbf{S}(1,1,-1,1)$，但实际上摄像机还是沿着负$z$轴观察，最后在OpenGL中的透视变换矩阵为：\\[\\mathbf{P}_{OpenGL}=\\left[\\matrix{\\frac{2n&#39;}{r-l} &amp;amp; 0 &amp;amp; \\frac{r+l}{r-l} &amp;amp; 0 \\\\0 &amp;amp; \\frac{2n&#39;}{t-b} &amp;amp; \\frac{t+b}{t-b} &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; -\\frac{f&#39;+n&#39;}{f&#39;-n&#39;} &amp;amp; -\\frac{2f&#39;n&#39;}{f&#39;-n&#39;} \\\\0 &amp;amp; 0 &amp;amp; -1 &amp;amp; 0}\\right]\\]但通常我们用一种更为简单的方式表达，即用户只需要提供垂直视野$\\phi$（vertical field of view），宽高比$a=w/h$（aspect）（$w\\times h$为屏幕分辨率），以及$n’$和$f’$。最终的透视变换矩阵为：\\[\\mathbf{P}_{OpenGL}=\\left[\\matrix{c/a &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; c &amp;amp; 0 &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; -\\frac{f&#39;+n&#39;}{f&#39;-n&#39;} &amp;amp; -\\frac{2f&#39;n&#39;}{f&#39;-n&#39;} \\\\0 &amp;amp; 0 &amp;amp; -1 &amp;amp; 0}\\right]\\]其中，$c=1.0/\\tan(\\phi/2)$。这个矩阵就是旧版gluPerspective()中的矩阵，来源于OpenGL Utility Library（GLU）。一些API（例如DirectX）把近平面映射到$z=0$（而不是$z=-1$），远平面映射到$z=1$。另外，DirectX使用左手坐标系作为观察坐标系，也就是说DirectX的摄像机从正$z$轴观察，并且$n$和$f$值都为正值，下面是DirectX中的透视变换矩阵：\\[\\mathbf{P}_{p[0,1]}=\\left[\\matrix{\\frac{2n&#39;}{r-l} &amp;amp; 0 &amp;amp; -\\frac{r+l}{r-l} &amp;amp; 0 \\\\0 &amp;amp; \\frac{2n&#39;}{t-b} &amp;amp; -\\frac{t+b}{t-b} &amp;amp; 0 \\\\0 &amp;amp; 0 &amp;amp; \\frac{f&#39;}{f&#39;-n&#39;} &amp;amp; -\\frac{f&#39;n&#39;}{f&#39;-n&#39;} \\\\0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0}\\right]\\]另外，需要注意的是，使用透视变换矩阵后，计算后的深度值（depth value）不会随输入的$p_z$值成线性变化。如图所示：我们很容易就可以推导出原因：$z_{NDC}=\\frac{d_{p_z}+e}{-p_z}=d-\\frac{e}{p_z}$其中，$d=−(f′+n′)/(f′−n′)$，$e=−2f′n′/(f′−n′)$。我们可以发现，输出的深度值$z_{NDC}$和输入的深度值$p_z$是成反比的。因此，近平面和远平面的位置会影响z-buffer​的精度，容易产生z-flighting。有几种方法可以增加深度值的精度： reversed z，即存储$1.0-z_NDC$。 Kemen建议使用对数对每个顶点得深度值重新映射：$z=w(log_2(max(10^{-6},1+w))f_c-1)$，（OpenGL）$z=w(log_2(max(10^{-6},1+w))f_c/2)$，（DirectX）其中$w$是投影矩阵之后的顶点的w值，常数$f_c=2/log_2(f+1)$，其中$f$是远平面。" }, { "title": "Real-Time Rendering 第二章 图形渲染流水线（The Graphics Rendering Pipeline）", "url": "/posts/RTR2/", "categories": "计算机, 图形学", "tags": "", "date": "2021-10-03 14:07:43 +0800", "snippet": "Real-Time Rendering第二章 图形渲染流水线这一章讲的是实时渲染的核心部分，即图形渲染流水线。图形渲染流水线的功能是通过给定的摄像机、三维物体信息、光源等信息，生成一个二维图像。因此，渲染流水线是实时渲染的底层工具。在现实世界中，流水线概念以许多不同的形式表现出来，从工厂装配线到快餐厨房。它也适用于图形渲染。管道由几个阶段组成，每个阶段执行总任务的一部分。流水线阶段并行执行，每个阶段取决于前一阶段的结果。理想情况下，将一个非流水线系统分为n个流水线，可以提供n倍的加速。提高性能是使用流水线的主要原因。实时渲染流水线大致分为四个主要阶段：应用阶段（application）、几何处理阶段（geometry processing）、光栅化阶段（rasterization）以及像素处理阶段（pixel processing），如下图所示。这些阶段中的每个阶段本身通常是一个流水线，这意味着它由几个子阶段组成。渲染速度可以用FPS表示，即每秒渲染的图像数。它也可以用赫兹（Hz）表示，赫兹只是1/s的符号，即更新频率。通常也只说明渲染图像所需的时间，以毫秒（ms）为单位。通常每个帧期间执行的计算的复杂度不同，生成图像的时间也会有所不同。顾名思义，应用阶段由应用程序驱动，通常在通用CPU上运行的软件中实现。这些CPU通常包括能够并行处理多个执行线程的多个核心，这使CPU能够高效地运行由应用阶段负责的大量任务。通常在CPU上执行的任务包括碰撞检测、全局加速算法、动画、物理模拟和许多其他任务，具体取决于应用程序的类型。几何处理阶段处理变换、投影和其他类型的几何体处理。这一阶段计算要绘制的内容、应如何绘制以及应在何处绘制。光栅化阶段通常接受三个顶点信息，这三个顶点信息组成一个三角形，然后计算这个三角形所包含的像素，然后把像素信息传递到像素处理阶段。最后，像素处理阶段逐像素确定其颜色，并且可以执行深度测试以确定该像素是否可见。这一阶段还可以将新的像素颜色和之前的像素颜色混合。几何处理阶段、光栅化阶段、像素处理阶段通常在包含许多可编程内核以及固定操作硬件的图形处理单元（GPU）上执行。 应用阶段开发者可以完全控制应用阶段中发生的事情，因为它通常在CPU上执行。因此，开发者可以完全确定应用阶段的实现，并在以后修改它以提高性能。此处的更改也会影响后续阶段。例如，在应用阶段使用适当的算法或设置可能会减少要渲染的三角形数量。然而，使用一种称为计算着色器的单独模式也可以让一些应用程序工作由GPU执行。此模式将GPU视为高度并行的通用处理器，忽略其专门用于渲染图形的特殊功能。应用阶段需要处理好待渲染的几何信息，包括点、线、三角形，再将几何信息传递给几何处理阶段。除此之外，应用阶段还要实现碰撞检测、键盘鼠标等外部设备的输入、加速算法（例如特定的剔除算法）等功能。 几何处理阶段几何处理阶段负责处理每个三角形以及顶点。此阶段进一步分为以下功能阶段：顶点着色（Vertex Shading）、投影（Projection）、裁剪（Clipping）和屏幕映射（Screen Mapping） 顶点着色阶段 顶点着色有两个主要任务，即计算顶点的位置和计算程序员想要的任何顶点输出数据，例如法线和纹理坐标。通常来说，物体的颜色是通过将灯光应用到每个顶点的位置和法线以及顶点处的颜色来计算的。因此，该可编程顶点处理单元被命名为顶点着色器（vertex shader）。 可选的顶点处理 当顶点处理完成后，GPU上可以按以下顺序执行几个可选阶段：曲面细分（tessellation）、几何体着色（geometry shading）和流输出（stream output）。它们的使用既取决于硬件的能力（并非所有GPU都有），也取决于程序员的需求。第一个可选阶段是曲面细分阶段。假设你有一个反弹的球对象。如果用一组三角形表示，可能会遇到质量或性能问题。你的球可能在5米之外看起来不错，但近距离观察各个三角形，特别是沿着轮廓，就会变得可见。如果使用更多三角形制作球以提高质量，当球离屏幕较远且仅覆盖屏幕上的几个像素时，可能会浪费大量的处理时间和内存。通过曲面细分，可以使用适当数量的三角形生成曲面。场景中的摄影机可用于确定生成多少个三角形：面片靠近时很多，面片远离时很少。第二个可选阶段是几何体着色器。此着色器早于曲面细分着色器，因此在GPU上更常见。它类似于曲面细分着色器，因为它接受各种基本体，并可以生成新的顶点。这是一个更为简单的阶段，因为创建的范围有限，输出的图元类型也非常有限。几何体着色器有多种用途，其中最常用的是粒子生成。想象一下模拟烟花爆炸，每个火球都可以用一个点，一个顶点来表示。几何体着色器可以将每个点转化为一个正方形（由两个三角形组成），覆盖多个像素，从而为我们提供一个图元进行着色。第三个可选阶段是流输出阶段。我们可以选择将处理后的顶点输出到数组以进行进一步处理，而不是将处理后的顶点沿管道的其余部分发送到屏幕。这些数据可以在以后的过程中由CPU或GPU本身使用。 投影阶段 从一个顶点到屏幕上，需要进行几个坐标空间变换。初始时，一个顶点在一个模型上，通过模型变换把顶点在模型空间中的位置和方向变换到世界空间。然后，为了能够观察到这个物体，我们还需要一个摄像机。摄像机在世界中也有位置和方向，我们再通过观察变换把顶点的世界坐标变换到观察空间。此时我们就得到了一个顶点在以摄像机为原点的位置和方向了。 裁剪阶段 只有全部或部分位于视图内的图元需要传递到光栅化阶段（以及随后的像素处理阶段），然后将它们绘制在屏幕上。完全在视图内的图元可以直接传递到下一阶段，完全在视图外的图元会被裁剪掉，不会被传递到下一阶段，而一部分在视图内、另一部分在视图外的图元需要进行额外处理，即在视图边缘生成新的顶点，如下图所示。 屏幕映射阶段 裁剪后的图元被传递到这一阶段后，图元在裁剪空间下还是三维坐标，这一阶段把图元的xy坐标通过平移、缩放变换为屏幕坐标，z坐标会重映射到一个区间。屏幕坐标和重映射的z值会传递到光栅化阶段。 光栅化阶段光栅化阶段有两个最重要的目标：计算图元覆盖了哪些像素，计算这些像素的颜色。该阶段包含以下两个阶段： 三角形设置（Triangle Setup） 该阶段主要用于计算三角形表面相关数据信息，以供下一阶段使用，该过程在专门为其设计的硬件上执行。 三角形遍历（Triangle Traversal） 在这个阶段会检查像素中心是否被三角形覆盖，如果被覆盖就会生成一个片元（fragment）。每个三角形片元的属性均由三个顶点的数据插值而生成，这些数据来自几何处理阶段的着色数据。 像素处理阶段此时，三角形或其他图元内部的所有像素都已找到，这是前面所有阶段组合的结果。像素处理阶段是对图元内部的像素或样本执行逐像素或逐样本计算和操作的阶段。像素着色阶段包含以下两个阶段： 像素着色阶段（Pixel Shading） 与三角形设置和遍历阶段（通常由专用硬件执行）不同，像素着色阶段由可编程GPU内核执行。为此，程序员需要为像素着色器提供一个程序（pixel shader）（在OpenGL中称为fragment shader）。这里可以使用多种技术，其中最重要的技术之一是纹理。 合并阶段（Merging） 这个阶段有两个主要任务： 决定每个片元的可见性，需要经过一些测试工作：深度测试，模板测试。 合成之前储存于缓冲器中的由之前像素着色阶段产生的片段颜色。 每个像素的信息存储在颜色缓冲区中，颜色缓冲区是一个矩形的颜色数组（每种颜色的红色、绿色和蓝色分量）。合并阶段负责将像素着色阶段产生的片段颜色与当前存储在缓冲区中的颜色相结合。这一阶段也被称为ROP（raster operations pipeline 或 render output unit）。与着色阶段不同，执行此阶段的GPU子单元通常不完全可编程。但是，它是高度可配置的，可以实现各种效果。此阶段还负责解决可见性问题。深度测试（Depth Test）：对于大多数甚至所有图形硬件，这是通过z-buffer（也称为深度缓冲）算法完成的。当一个图元将要被绘制时，需要将他的z-value和z-buffer中的z-value进行比较，如果新的z-value较小，那这个图元将会被绘制，z-buffer中的z-value会更新为新的z-value；反之，如果新的z-value较大，那这个图元就会被抛弃。z-buffer算法简单，具有O(n)的时间复杂度（其中n是渲染的图元的数量），适用于可以为每个（相关）像素计算z值的图元。该算法允许大多数图元以任何顺序渲染，这也是它流行的另一个原因。但是，z-buffer在屏幕上的每个点只存储一个深度，因此不能用于部分透明的图元。必须在所有不透明图元之后，按照从后到前的顺序，或使用单独的顺序独立算法渲染这些图元。我们已经提到，颜色缓冲区用于存储颜色，z-buffer存储每个像素的z值。模板测试（Stencil Test）：和深度测试一样，它也可能会丢弃片段。接下来，被保留的片段会进入深度测试。模板测试是根据又一个缓冲来进行的，它叫做模板缓冲（Stencil Buffer），我们可以在渲染的时候更新它来获得一些很有意思的效果。一个模板缓冲中，通常每个模板值（Stencil Value）是8位的。所以每个像素/片段一共能有256种不同的模板值。我们可以将这些模板值设置为我们想要的值，然后当某一个片段有某一个模板值的时候，我们就可以选择丢弃或是保留这个片段了。当图元到达并通过以上阶段时，从相机的角度可以看到的图元将显示在屏幕上。屏幕显示颜色缓冲区的内容。当渲染数据量较大时，渲染可能需要很长时间，还可能会出现闪烁现象。为了解决这些问题，需要使用双缓冲。这意味着场景的渲染在屏幕外的back buffer中进行。在back buffer中渲染场景后，back buffer的内容将与先前在屏幕上显示的front buffer的内容交换。交换通常发生在垂直回溯（vertical retrace）期间，此时这样做是安全的。" }, { "title": "Real-Time Rendering 第一章 介绍（Introduction）", "url": "/posts/RTR1/", "categories": "计算机, 图形学", "tags": "", "date": "2021-10-03 14:07:43 +0800", "snippet": "Real-Time Rendering第一章 介绍实时渲染即在计算机上快速生成图像，它是计算机图形学中互动性最强的领域。屏幕上会出现一幅图像，观看者会采取行动或做出反应，这种反馈会影响下一步生成的内容。这种反应和渲染的循环速度非常快，以至于观众看不到单个图像，而是沉浸在动态过程中。图像的显示速率以每秒帧数（FPS）或赫兹（Hz）为单位进行测量。以每秒一帧的速度，几乎没有交互性；用户痛苦地意识到每个新图像的到来。每秒6帧左右，互动感开始增强。视频游戏的目标是30、60、72或更高的FPS；在这些速度下，用户专注于行动和反应。以24 FPS的速度观看屏幕上的图像可能是可以接受的，但更高的速度对于最小化响应时间很重要。只要15毫秒的时间延迟就可以减缓和干扰交互。例如，用于虚拟现实的头戴式显示器通常需要90 FPS以最小化延迟。实时渲染不仅仅是交互性。如果速度是唯一的标准，那么任何快速响应用户命令并在屏幕上绘制任何内容的应用程序都符合条件。实时渲染通常意味着生成三维图像。图形硬件的进步推动了交互式计算机图形领域的研究。我们将重点介绍提高速度和改善图像质量的方法，同时还将介绍加速算法和图形API的功能和局限性。来自极限竞速7的一张截图：我们无法深入讨论每一个主题，因此我们的目标是展示关键概念和术语，解释该领域最健壮和实用的算法，并提供更好的方向，以获取更多信息。" } ]
