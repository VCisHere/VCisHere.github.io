<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>VCisHere</title><subtitle>VC的博客</subtitle> <updated>2023-02-17T19:27:25+08:00</updated> <author> <name>VCisHere</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2023 VCisHere </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>分布式数据库事务-Percolator</title><link href="/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1-Percolator/" rel="alternate" type="text/html" title="分布式数据库事务-Percolator" /><published>2023-02-03T14:07:43+08:00</published> <updated>2023-02-17T19:27:06+08:00</updated> <id>/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1-Percolator/</id> <content src="/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1-Percolator/" /> <author> <name>VCisHere</name> </author> <category term="计算机" /> <category term="DB" /> <summary> PDF </summary> </entry> <entry><title>DBMS与mmap</title><link href="/posts/mmap/" rel="alternate" type="text/html" title="DBMS与mmap" /><published>2022-12-30T16:03:15+08:00</published> <updated>2022-12-30T16:03:15+08:00</updated> <id>/posts/mmap/</id> <content src="/posts/mmap/" /> <author> <name>VCisHere</name> </author> <category term="计算机" /> <category term="DB" /> <summary> mmap 文件 I/O 是操作系统提供的一项功能，它将二级存储中的文件内容映射到程序的地址空间。然后，程序通过指针访问页面，就像文件完全位于内存中一样。操作系统只在程序引用时透明地加载页面，并在内存填满时自动驱逐页面。 mmap 的易用性几十年来一直吸引着数据库管理系统（DBMS）的开发者，作为实现 buffer pool 的一个可行的替代方案。然而，mmap 存在严重的正确性和性能问题，这些问题并不明显。这些问题使得在现代 DBMS 中正确有效地使用 mmap 很困难，甚至不可能。事实上，几个流行的 DBMS 最初使用 mmap 来支持大于内存的数据库，但很快就遇到了这些隐藏的危险，迫使他们在付出巨大的工程成本后转而自己管理文件 I/O。这样一来，mmap 和 DBMS 就像咖啡和辛辣的食物：一个不幸的组合，事后才发现。 由于开发者不断尝试在新的 DBMS 中使用 mmap，我... </summary> </entry> <entry><title>brpc学习-bthread</title><link href="/posts/brpc-1/" rel="alternate" type="text/html" title="brpc学习-bthread" /><published>2022-10-17T16:03:15+08:00</published> <updated>2022-10-17T16:03:15+08:00</updated> <id>/posts/brpc-1/</id> <content src="/posts/brpc-1/" /> <author> <name>VCisHere</name> </author> <category term="计算机" /> <category term="其他" /> <summary> brpc 简介 brpc 是一个 C++ 编写的高性能分布式 RPC 框架，最初由百度于 2014 年创建，在 2017 年开源，于 2018 年进入 Apache 孵化器。如今 brpc 已经被广泛地应用于各大公司，包括百度、字节跳动、滴滴、bilibili、网易等。 整体架构 一个RPC的基本流程： Client 通过 Channel（通道，可视为命名服务的 Client）进行 RPC 调用 通过命名服务中的 Server 列表和某种负载均衡算法找到访问的 Server 使用某种协议进行序列化请求通过套接字发送 Sever 反序列化通过方法名找到对应服务 Sever 执行方法调用后将结果返回给 Client bthread 线程库 介绍 bthread 是 br... </summary> </entry> <entry><title>C++的一些在线工具</title><link href="/posts/C++%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/" rel="alternate" type="text/html" title="C++的一些在线工具" /><published>2022-10-17T16:03:15+08:00</published> <updated>2022-10-17T16:03:15+08:00</updated> <id>/posts/C++%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/</id> <content src="/posts/C++%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/" /> <author> <name>VCisHere</name> </author> <category term="计算机" /> <category term="C++" /> <summary> C++的一些在线工具 看代码编译展开 https://cppinsights.io/ benchmark https://quick-bench.com/ 编译开销 https://build-bench.com/ 看编译成的汇编 https://gcc.godbolt.org/ </summary> </entry> <entry><title>C++ memory order</title><link href="/posts/C++-memory-order/" rel="alternate" type="text/html" title="C++ memory order" /><published>2022-10-17T16:03:15+08:00</published> <updated>2022-10-17T16:03:15+08:00</updated> <id>/posts/C++-memory-order/</id> <content src="/posts/C++-memory-order/" /> <author> <name>VCisHere</name> </author> <category term="计算机" /> <category term="C++" /> <summary> memory_order_relaxed 没有同步或顺序制约，仅对此操作要求原子性 memory_order_release 对写操作施加 release 语义，在代码中这条语句前面的所有读写操作都无法被重排到这个操作之后 当前线程内的所有写操作，对于其他对这个原子变量进行 acquire 的线程可见 当前线程内的与这块内存有关的所有写操作，对于其他对这个原子变量进行 consume 的线程可见 memory_order_consume 对当前要读取的内存施加 consume 语义，在代码中这条语句后面所有与这块内存有关的读写操作都无法被重排到这个操作之前 在这个原子变量上施加 release 语义的操作发生之后，consume 可以保证读到所有在 release 前发生的并且与这块内存有关的写入 memory_order_acquire ... </summary> </entry> </feed>
