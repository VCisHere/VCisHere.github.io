<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="天前"><meta name="hour-prompt" content="小时前"><meta name="minute-prompt" content="分钟前"><meta name="justnow-prompt" content="刚刚"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="Real-Time Rendering 第四章 变换（Transforms）" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="Real-Time Rendering" /><meta property="og:description" content="Real-Time Rendering" /><link rel="canonical" href="/posts/RTR4/" /><meta property="og:url" content="/posts/RTR4/" /><meta property="og:site_name" content="VCisHere" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-10-06T18:58:15+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Real-Time Rendering 第四章 变换（Transforms）" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"headline":"Real-Time Rendering 第四章 变换（Transforms）","dateModified":"2021-10-08T23:51:18+08:00","datePublished":"2021-10-06T18:58:15+08:00","description":"Real-Time Rendering","url":"/posts/RTR4/","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/RTR4/"},"@type":"BlogPosting","@context":"https://schema.org"}</script><title>Real-Time Rendering 第四章 变换（Transforms） | VCisHere</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="VCisHere"><meta name="application-name" content="VCisHere"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="zh-CN"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/avatar.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">VCisHere</a></div><div class="site-subtitle font-italic">(°ー°〃)</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/VCisHere" aria-label="github" class="order-3" target="_blank" rel="noopener" > <i class="fab fa-github"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['vcishere01','gmail.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>Real-Time Rendering 第四章 变换（Transforms）</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Real-Time Rendering 第四章 变换（Transforms）</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> VCisHere </span> 发表于 <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="2021-10-06, 18:58 +0800" >2021-10-06<i class="unloaded">2021-10-06T18:58:15+08:00</i> </span></div><div> <span> 更新于 <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="2021-10-08, 23:51 +0800" >2021-10-08<i class="unloaded">2021-10-08T23:51:18+08:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="7924 字">44 分钟 阅读</span></div></div><div class="post-content"><h1 id="real-time-rendering">Real-Time Rendering</h1><h2 id="第四章-变换">第四章 变换</h2><p>变换（Transform）是对点、矢量 、颜色等实体以某种方式进行转换的一种操作。利用变换，你可以对物体、灯光、摄像机进行位移、缩放等操作。</p><p>变换可分为线性变换和非线性变换。</p><p>线性变换是一种保留矢量加法和标量乘法的变换。即：</p><p>$f(x)+f(y)=f(x+y)$</p><p>$kf(x) = f(kx)$</p><p>例如，$f(x)=5x$是一种变换，它取一个矢量并将每个元素乘以5。同时他也是一个线性变换，因为他满足上面的两个等式。这个函数是一种缩放变换，因为它更改对象的比例（大小）。旋转变换是另一种围绕原点旋转矢量的线性变换。缩放和旋转变换，实际上是三元素矢量的所有线性变换，可以使用3×3矩阵表示。</p><p>然而，3×3矩阵具有局限性。现在我们需要平移变换，例如$f(x)=x+(7, 3, 2)$，很显然，平移变换是非线性变换。</p><p>为了组合线性变换和平移，我们需要使用仿射变换。仿射变换通常存储为4×4矩阵。仿射变换是先执行线性变换，然后执行平移的变换。为了表示四维矢量，我们使用齐次表示法，以相同的方式表示点和方向矢量。一个方向矢量可以表示为$v=(v_x,v_y,v_z,0)^T$，一个点可以表示为$v=(v_x,v_y,v_z,1)^T$。</p><p>所有平移、旋转、缩放、反射和裁剪矩阵都是仿射矩阵。仿射矩阵的主要特点是它保留了直线的平行性，但不一定保留长度和角度。仿射变换也可以是单个仿射变换的任何串联序列。</p><h3 id="基础变换basic-transforms">基础变换（Basic Transforms）</h3><p>下面我们介绍最基本的变换，如平移、旋转、缩放、剪切、复合变换、刚体变换和法线变换。</p><ul><li>平移变换</ul><p>从一个位置到另一个位置的变化由平移矩阵$T$表示。这个矩阵可以将一个实体位移$t=(t_x,t_y,t_z)$个单位。$T$矩阵形如：</p>\[T=\left[\matrix{1&amp;0&amp;0&amp;t_x\\0&amp;1&amp;0&amp;t_y\\0&amp;0&amp;1&amp;t_z\\0&amp;0&amp;0&amp;1}\right]\]<p>我们可以使用矩阵乘法来表示对一个点进行平移变换：</p>\[\left[\matrix{1&amp;0&amp;0&amp;t_x\\0&amp;1&amp;0&amp;t_y\\0&amp;0&amp;1&amp;t_z\\0&amp;0&amp;0&amp;1}\right]\left[\matrix{x\\y\\z\\1}\right]=\left[\matrix{x+t_x\\y+t_y\\z+t_z\\1}\right]\]<p>但如果我们对一个方向矢量进行平移变换：</p>\[\left[\matrix{1&amp;0&amp;0&amp;t_x\\0&amp;1&amp;0&amp;t_y\\0&amp;0&amp;1&amp;t_z\\0&amp;0&amp;0&amp;1}\right]\left[\matrix{x\\y\\z\\0}\right]=\left[\matrix{x\\y\\z\\0}\right]\]<p>可以发现，平移变换并不会影响方向矢量。这点很容易理解，因为矢量没有位置属性，所以平移不应该对四维矢量产生影响。</p><p>平移矩阵的逆矩阵就是反向平移得到的矩阵，即：</p>\[\left[\matrix{1&amp;0&amp;0&amp;-t_x\\0&amp;1&amp;0&amp;-t_y\\0&amp;0&amp;1&amp;-t_z\\0&amp;0&amp;0&amp;1}\right]\]<ul><li>旋转变换：</ul><p>我们知道，旋转操作需要指定一个旋转轴，这个旋转轴不一定是空间中的坐标轴。</p><p>如果我们需要把点绕着$x$轴旋转$\theta$度，可以使用下面的矩阵：</p>\[R_x(\theta)=\left[\matrix{1&amp;0&amp;0&amp;0\\0&amp;cos\theta&amp;-sin\theta&amp;0\\0&amp;sin\theta&amp;cos\theta&amp;0\\0&amp;0&amp;0&amp;1}\right]\]<p>绕$y$轴的旋转：</p>\[R_y(\theta)=\left[\matrix{cos\theta&amp;0&amp;sin\theta&amp;0\\0&amp;1&amp;0&amp;0\\-sin\theta&amp;0&amp;cos\theta&amp;0\\0&amp;0&amp;0&amp;1}\right]\]<p>绕$z$轴的旋转：</p>\[R_z(\theta)=\left[\matrix{cos\theta&amp;-sin\theta&amp;0&amp;0\\sin\theta&amp;cos\theta&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1}\right]\]<p>旋转矩阵的逆矩阵是旋转相反角度得到的变换矩阵。</p><ul><li>缩放变换</ul><p>我们可以对一个点沿空间的$x$轴、$y$轴和$z$轴进行缩放。由缩放矩阵$S$表示。$S$矩阵形如：</p>\[S=\left[\matrix{k_x&amp;0&amp;0&amp;0\\0&amp;k_y&amp;0&amp;0\\0&amp;0&amp;k_z&amp;0\\0&amp;0&amp;0&amp;1}\right]\]<p>同样，我们可以使用矩阵乘法来表示一个缩放变换：</p>\[\left[\matrix{k_x&amp;0&amp;0&amp;0\\0&amp;k_y&amp;0&amp;0\\0&amp;0&amp;k_z&amp;0\\0&amp;0&amp;0&amp;1}\right]\left[\matrix{x\\y\\z\\1}\right]=\left[\matrix{k_xx\\k_yy\\k_zz\\1}\right]\]<p>对方向矢量也可以使用同样的矩阵进行缩放：</p>\[\left[\matrix{k_x&amp;0&amp;0&amp;0\\0&amp;k_y&amp;0&amp;0\\0&amp;0&amp;k_z&amp;0\\0&amp;0&amp;0&amp;1}\right]\left[\matrix{x\\y\\z\\0}\right]=\left[\matrix{k_xx\\k_yy\\k_zz\\0}\right]\]<p>缩放矩阵的逆矩阵是使用原缩放系数的倒数来对点或方向矢量进行缩放，即：</p>\[\left[\matrix{1/k_x&amp;0&amp;0&amp;0\\0&amp;1/k_y&amp;0&amp;0\\0&amp;0&amp;1/k_z&amp;0\\0&amp;0&amp;0&amp;1}\right]\]<ul><li>剪切变换</ul><p>剪切变换可以用于扭曲模型，例如方形变为平行四边形，任意一边都可以被拉伸。</p><p>一共有六种基本剪切矩阵：$H_{xy}(s)$，$H_{xz}(s)$，$H_{yx}(s)$，$H_{yz}(s)$，$H_{zx}(s)$，$H_{zy}(s)$。</p><p>第一个下标表示哪个坐标将要被变换（剪切），第二个下标表示用哪个坐标来变换（剪切）。</p><p>例如：</p>\[H_{xz}(s)=\left[\matrix{1&amp;0&amp;s&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1}\right]\] \[p=(p_x,p_y,p_z)^T\] \[H_{xz}(s)p=\left[\matrix{1&amp;0&amp;s&amp;0\\0&amp;1&amp;0&amp;0\\0&amp;0&amp;1&amp;0\\0&amp;0&amp;0&amp;1}\right]\left[\matrix{p_x\\p_y\\p_z\\1}\right]=\left[\matrix{p_x+sp_z\\p_y\\p_z\\1}\right]\]<p>剪切矩阵的逆矩阵是沿相反方向的剪切，即：</p><p>$H_{ij}^{-1}(s)=H_{ij}(-s)$</p><ul><li>复合变换</ul><p>为了提高效率，我们需要将矩阵序列连接成单个矩阵。例如，假设我们有一个具有数百万个顶点的游戏场景，场景中的所有对象都必须缩放、旋转并最终平移。</p><p>现在，不是将所有顶点与三个矩阵中的每一个相乘，而是将三个矩阵连接成一个矩阵。然后将此单个矩阵应用于顶点。</p><p>我们可以把平移、旋转和缩放组合起来，来形成一个复杂的变换过程。由于矩阵乘法不满足交换律，矩阵相乘的顺序不同会导致变换的结果不同。</p><p>例如，我们现在有两个变换矩阵，一个缩放矩阵$S$和一个旋转矩阵$R$，$S(2,0.5,1)$表示将$x$坐标变为$2$倍，将$y$坐标变为$1/2$，$R_z(\pi/6)$表示沿$z$轴旋转$\pi/6$，这两个矩阵相乘有两种顺序，$RS$和$SR$，他们实现的变换是不同的：</p><p><img data-proofer-ignore data-src="/assets/img/4-1.png" alt="" /></p><p>在绝大多数情况下，我们约定变换的顺序就是先缩放，再旋转，最后平移。即复合变换矩阵为：</p><p>$C=TRS$</p><p>除了需要注意不同类型的变换顺序外，我们有时还需要小心旋转的变换顺序。</p><p>如果我们需要同时绕着3个轴进行旋转，是先绕$x$轴、再绕$y$轴最后绕$z$轴旋转还是按其他的旋转顺序呢？</p><p>首先，我们有两种旋转方法：内旋和外旋。</p><ul><li>每次旋转是绕固定轴（一个固定参考系，比如世界坐标系）旋转，称为外旋。<li>每次旋转是绕自身旋转之后的轴旋转，称为内旋。</ul><p>按照内旋方式，$Z$-$Y$-$X$旋转顺序（指先绕自身轴$Z$，再绕自身轴$Y$，最后绕自身轴$X$），可得旋转矩阵（内旋是右乘）：</p><p>$R_1=R_z(\gamma)R_y(\beta)R_x(\alpha)$</p><p>按照外旋方式，$X$-$Y$-$Z$旋转顺序（指先绕固定轴$X$，再绕固定轴$Y$，最后绕固定轴$Z$），可得旋转矩阵（外旋是左乘）：</p><p>$R_2=R_z(\gamma)R_y(\beta)R_x(\alpha)$</p><p>两种旋转方法按上面两种不同的顺序旋转结果是相同的。</p><ul><li>刚体变换</ul><p>当一个人从桌子上拿起一个实心物体（比如一支笔）并将其移动到另一个位置，例如衬衫口袋，只有物体的方向和位置会改变，而物体的形状通常不会受到影响。这种变换仅由平移和旋转的复合组成，称为刚体变换。</p><p>刚体变换可以表示为：</p>\[X=T(t)R=\left[\matrix{r_{00}&amp;r_{01}&amp;r_{02}&amp;t_x\\r_{10}&amp;r_{11}&amp;r_{12}&amp;t_y\\r_{20}&amp;r_{21}&amp;r_{22}&amp;t_z\\0&amp;0&amp;0&amp;1}\right]\]<p>用途：摄像机LookAt</p><ul><li>法线变换</ul><p>一般来说，点和绝大部分方向矢量都可以使用同一个4×4或3×3的变换矩阵把其从坐标空间A变换到坐标空间B中。但在变换法线的时候，如果使用同一个变换矩阵，可能就无法确保维持法线的垂直性。如图：</p><p><img data-proofer-ignore data-src="/assets/img/4-2.png" alt="" /></p><p>我们先来了解一下另一种方向矢量：切线（tangent），也被称为切矢量（tangent vector）。与法线类似，切线往往也是模型顶点携带的一种信息。它通常与纹理空间对齐，而且与法线方向垂直.</p><p>由于切线是由两个顶点之间的差值计算得到的，因此我们可以直接使用用于变换顶点的变换矩阵来变换切线。假设，我们使用变换矩阵$M_{A \rightarrow B}$来变换顶点，可以由下面的式子直接得到变换后的切线：</p><p>$T_B=M_{A \rightarrow B}T_A$</p><p>我们可以由数学约束条件来推出变换法线的矩阵。我们知道同一个顶点的切线$T_{A}$和法线$N_{A}$必须满足垂直条件，即$T_{A} \cdot N_{A}$。</p><p>给定变换矩阵$M_{A \rightarrow B}$，我们已经知道$T_B=M_{A \rightarrow B}T_A$。我们现在想要找到一个矩阵$G$来变换法线$N_{A}$，使得变换后的法线仍然与切线垂直，即：</p><p>$T_{B} \cdot N_{B}=(M_{A \rightarrow B} \cdot T_{A}) \cdot (GN_{A})=0$</p><p>$(M_{A \rightarrow B} \cdot T_{A}) \cdot (GN_{A})=(M_{A \rightarrow B} \cdot T_{A})^T \cdot (GN_{A})=T_{A}^T(M_{A \rightarrow B}^TG)N_{A}=0$</p><p>又$T_{A} \cdot N_{A}=0$</p><p>因此如果$M_{A \rightarrow B}^TG=I$，那么上式成立。</p><p>即$G=(M_{A \rightarrow B}^T)^{-1}$。</p><p>另外，如果变换矩阵$M_{A \rightarrow B}$为正交矩阵，即变换只包括旋转变换，那么$M_{A \rightarrow B}^T=M_{A \rightarrow B}^{-1}$，即$(M_{A \rightarrow B}^T)^{-1}=M_{A \rightarrow B}$。</p><h3 id="特殊的矩阵变换和运算special-matrix-transforms-and-operations">特殊的矩阵变换和运算（Special Matrix Transforms and Operations）</h3><p>接下来将介绍对实时渲染至关重要的几种矩阵变换和运算。</p><ul><li>欧拉变换</ul><p>这种变换是一种简单的方法，可以构造一个矩阵将实体定向到某个方向。它的名字来自伟大的瑞士数学家莱昂哈德·欧拉（Leonhard Euler）（1707-1783）。</p><p>首先，我们要确定模型自身的坐标轴。</p><p>最常见的是朝向沿负$z$轴，头顶沿$y$轴，如图所示。</p><p><img data-proofer-ignore data-src="/assets/img/4-3.png" alt="" /></p><p>欧拉变换是三个矩阵的乘积，即图中所示的旋转，表示为：</p><p>$E(h,p,r)=R_z(r)R_x(p)R_y(h)$</p><p>矩阵相乘可以用24种不同的顺序，其中上面这种是最常用的。</p><p>其中，$r$代表roll角，沿$z$轴旋转；$p$代表pitch角，沿$x$轴旋转；$h$代表head角，也称为yaw角，沿$y$轴旋转。</p><p>注意欧拉变换不仅可以用于设置摄像机的朝向，也可以设置任何物体或实体的朝向。这些变换可以在全局的世界坐标系下完成，也可以在相对于某个物体的局部坐标系完成。</p><p>尽管对于小的角度或者观察者朝向改变，欧拉角很有用，但它也有一些严重的限制。同时结合使用两个欧拉角集合是困难的。例如，在两个欧拉角集合间进行插值不是简单地对两组集合的三个角度分别进行插值。因为两个不同的欧拉角集合可能给出相同的朝向，此时任何插值都不会旋转物体。这些是考虑用四元数（Quaternion）等来代替欧拉角的原因。</p><ul><li>从欧拉变换中提取参数</ul><p>有时从欧拉变换矩阵，提取出欧拉角$h$，$p$，$r$是有用的，过程如下：</p>\[E(h,p,r)=\left[\matrix{e_{00}&amp;e_{01}&amp;e_{02}\\e_{10}&amp;e_{11}&amp;e_{12}\\e_{20}&amp;e_{21}&amp;e_{22}}\right]=R_z(r)R_x(p)R_y(h)\]<p>连接三个旋转矩阵后得到：</p>\[E=\left[\matrix{\cos r \cos h - \sin r \sin p \sin h &amp; - \sin r \cos p &amp; \cos r \sin h + \sin r \sin p \cos h\\ \sin r \cos h + \cos r \sin p &amp; \sin h \cos r &amp; \cos p \sin r \sin h - \cos r \sin p \cos h\\ \cos p \sin h&amp; \sin p &amp; \cos p \cos h}\right]\]<p>显然，$\sin p = e_{21}$，且：</p><p>$\frac{e_{01}}{e_{11}}=\frac{-\sin r}{\cos r}=-\tan r$</p><p>$\frac{e_{20}}{e_{22}}=\frac{-\sin h}{\cos h}=-\tan h$</p><p>因此可解出三个欧拉角分别为：</p><p>$h=atan2(-e_{20},e_{22})$</p><p>$p=arcsin(-e_{21})$</p><p>$r=atan2(-e_{01},e_{11})$</p><p>有一个特殊的情形需要处理。如果$\cos p=0$，则会出现万向节锁（gimbal lock），旋转角度$r,h$将会绕相同的轴旋转（可能方向相反，这取决于$p$的值为$-\pi/2$还是$\pi/2$），这样只有一个角度（$r,h$中的一个）需要推导。如果我们任意地设$h=0$，则</p>\[E=\left[\matrix{\cos r &amp; - \sin r \cos p &amp; \sin r \sin p \\ \sin r &amp; \cos r \cos p &amp; - \cos r \sin p \\ 0&amp; \sin p &amp; \cos p}\right]\]<p>因为$p$不影响第一列，所以当$\cos p=0$时，我们可以使用$\sin r / \cos r = \tan r = e_{10}/e_{00}$，可以得到：$r=atan2(e_{10},e_{00})$</p><p>注意$\arcsin$的定义域为$[-\pi / 2, \pi / 2]$，这意味着如果$E$创建时包含了一个在此定义域范围外的$p$，则不能提取出原始参数。</p><p>即：不同的$h,p,r$组合可能产生相同的欧拉变换。</p><p>当使用欧拉变换时，万向锁（gimbal lock）可能会出现。当某个旋转使得三个自由度(对应$r,p,h$或者说对应$x,y,z$轴)中的一个消失时，万向锁会出现。例如，变换顺序为$xyz$，假设第一个旋转变换为绕$y$轴旋转$\pi/2$，然后再进行第二个旋转变换。但第一个旋转变换已经导致$z$轴和原始的$x$轴对齐，这样最后绕$z$轴的旋转就是冗余的了。</p><h3 id="四元数quaternion">四元数（Quaternion）</h3><p>四元数最早于1843年由Sir William Rowan Hamilton发明，作为复数(complex numbers)的扩展。直到1985年才由Shoemake把四元数引入到计算机图形学中。四元数在一些方面优于Euler angles(欧拉角)和matrices。任意一个三维空间中的定向都可以被表示为一个绕某个特定轴的旋转。给定旋转轴及旋转角度，很容易把其它形式的旋转表示转化为四元数或者从四元数转化为其它形式。四元数可以用于稳定的旋转插值，而这些在欧拉角中是很难实现的。</p><p>一个复数具有实部和虚部，每一部分由两个实数表示，其中第一个实数要乘以$\sqrt{-1}$。相似地，四元数由四部分组成，一个实部，三个虚部。三个虚部与旋转轴密切相关，而旋转角度影响四个部分。这里用向量来表示四元数，但是为了和普通矢量进行区分，我们在其上加了个“帽子”: $\hat{\mathbf{q}}$。</p><p>接下来先介绍四元数的基本数学运算，再描述四元数用于旋转等。</p><ul><li><p>数学背景</p><li><ul><li>四元数定义：</ul></ul><p>一个四元数$\hat{\mathbf{q}}$可以被定义以下形式：</p><p>$\hat{\mathbf{q}}=(\hat{\mathbf{q_v}},\hat{\mathbf{q_w}})=iq_x+jq_y+kq_z+q_w=\hat{\mathbf{q_v}}+\hat{\mathbf{q_w}}$</p><p>其中，</p><p>$\hat{\mathbf{q_v}}=iq_x+jq_y+kq_z=(q_x,q_y,q_z)$</p><p>$i^2=j^2=k^2=-1$，$jk=-kj=i$，$ki=-ik=j$，$ij=-ji=k$</p><p>$q_w$为四元数的实部，$\mathbf{q}_v$是虚部，$i,j,k$为虚数单位。</p><p>对于虚部$\mathbf{q}_v$，我们可以施加所有普通矢量运算操作，例如加法、缩放、点乘、叉积等。</p><p>根据四元数的定义，可以推导出两个四元数$\hat{\mathbf{q}}$和$\hat{\mathbf{r}}$间的乘法运算。注意，虚数单位之间的乘法不满足交换律。</p><ul><li><ul><li>乘法：</ul></ul><p>$\hat{\mathbf{q}}\hat{\mathbf{r}}=(iq_x+jq_y+kq_z+q_w)(ir_x+jr_y+kr_z+r_w)$</p><p>$=i(q_yr_z-q_zr_y+r_wq_x+q_wr_x)$</p><p>$+j(q_zr_x-q_xr_z+r_wq_y+q_wr_y)$</p><p>$+k(q_xr_y-q_yr_x+r_wq_z+q_wr_z)$</p><p>$+q_wr_w-q_xr_x-q_yr_y-q_zr_z$</p><p>$=(\hat{\mathbf{q_v}}\times\hat{\mathbf{r_v}}+r_w\hat{\mathbf{q_v}}+q_w\hat{\mathbf{r_v}},q_wr_w-\hat{\mathbf{q_v}}\cdot\hat{\mathbf{r_v}})$</p><ul><li><ul><li>加法：</ul></ul><p>$\hat{\mathbf{q}}+\hat{\mathbf{r}}=(\hat{\mathbf{q_v}}+\hat{\mathbf{r_v}},q_w+r_w)$</p><ul><li><ul><li>共轭：</ul></ul><p>$\hat{\mathbf{q}}^\ast=(-\hat{\mathbf{q_v}},q_w)$</p><ul><li><ul><li>模：</ul></ul><p>$n(\hat{\mathbf{q}})=\sqrt{\hat{\mathbf{q}}\hat{\mathbf{q}}^\ast}=\sqrt{\hat{\mathbf{q}}\ast\hat{\mathbf{q}}}=\sqrt{\hat{\mathbf{q_v}}\cdot\hat{\mathbf{q_v}}+q_w^2}=\sqrt{q_x^2+q_y^2+q_z^2+q_w^2}$</p><ul><li><ul><li>$\hat{\mathbf{i}}=(\mathbf{0},1)$</ul><li><ul><li>四元数的逆：</ul></ul><p>$\hat{\mathbf{q}}^{-1}\hat{\mathbf{q}}=\hat{\mathbf{q}}\hat{\mathbf{q}}^{-1}=1$</p><p>$n(\hat{\mathbf{q}})^2=\hat{\mathbf{q}}\hat{\mathbf{q}}^\ast\Leftrightarrow\frac{\hat{\mathbf{q}}\hat{\mathbf{q}}^\ast}{n(\hat{\mathbf{q}})^2}=1$</p><p>所以四元数的逆为：</p><p>$\hat{\mathbf{q}}^{-1}=\frac{1}{n(\hat{\mathbf{q}})^2}\hat{\mathbf{q}}^\ast$</p><ul><li><ul><li>四元数的一些规则：</ul></ul><p>共轭规则：</p><p>$(\hat{\mathbf{q}}^\ast)^\ast=\hat{\mathbf{q}}$</p><p>$(\hat{\mathbf{q}}+\hat{\mathbf{r}})^\ast=\hat{\mathbf{q}}^\ast+\hat{\mathbf{r}}^\ast$</p><p>$(\hat{\mathbf{q}}\hat{\mathbf{r}})^\ast=\hat{\mathbf{r}}^\ast\hat{\mathbf{q}}^\ast$</p><blockquote><ol><li><p>一个四元数的共轭的共轭是该四元数本身。</p><li><p>两个四元数的和的共轭是它们共轭的和。</p><li><p>两个四元数乘积的共轭是它们共轭调换顺序后的乘积。</p></ol></blockquote><p>模规则：</p><p>$n(\hat{\mathbf{q}}\hat{\mathbf{r}})=n(\hat{\mathbf{q}})n(\hat{\mathbf{r}})$</p><blockquote><ol><li>一个四元数的模等于其共轭的模。<li>两个四元数乘积的模等于它们模的乘积。</ol></blockquote><p>乘法规则：</p><p>$\hat{\mathbf{p}}(s\hat{\mathbf{q}}+t\hat{\mathbf{r}})=s\hat{\mathbf{p}}\hat{\mathbf{q}}+t\hat{\mathbf{p}}\hat{\mathbf{r}}$</p><p>$(s\hat{\mathbf{p}}+t\hat{\mathbf{q}})\hat{\mathbf{r}}=s\hat{\mathbf{p}}\hat{\mathbf{r}}+t\hat{\mathbf{q}}\hat{\mathbf{r}}$</p><p>$\hat{\mathbf{p}}(\hat{\mathbf{q}}\hat{\mathbf{r}})=(\hat{\mathbf{p}}\hat{\mathbf{q}})\hat{\mathbf{r}}$</p><ul><li><ul><li>单位四元数：</ul></ul><p>模为1的四元数为单位四元数。</p><p>可推导出单位四元数$\hat{\mathbf{q}}$可以写作：</p>\[\hat{\mathbf{q}}=(\sin\phi\mathbf{u}_q,\cos\phi)=\sin\phi\mathbf{u}_q+\cos\phi\]<p>其中\(\mathbf{u}_{q}\)是一个三维向量，且$\vert\vert\mathbf{u}_{q}\vert\vert=1$。因为当且仅当\(\vert\vert\mathbf{u}_{q}\vert\vert=1\)时，</p>\[n(\hat{\mathbf{q}})=n(\sin\phi\mathbf{u}_q,\cos\phi)=\sqrt{\sin^2\phi(\mathbf{u}_q\cdot\mathbf{u}_q)+\cos^2\phi}=\sqrt{\sin^2\phi+\cos^2\phi}=1\]<p>对于复数，一个二维单位向量可以写作$\cos\phi+i\sin\phi=e^{i\phi}$，对于四元数，等价的有：</p><p>$\hat{\mathbf{q}}=\sin\phi\mathbf{u}_q+\cos\phi=e^{\phi\mathbf{u}_q}$</p><ul><li><ul><li>四元数对数和指数函数：</ul></ul><p>$\log(\hat{\mathbf{q}})=\log(e^{\phi\mathbf{u}_q})=\phi\mathbf{u}_q$</p><p>$\hat{\mathbf{q}}^t=(\sin\phi\mathbf{u}_q+\cos\phi)^t=e^{\phi t \mathbf{u}_q}=\sin(\phi t)\mathbf{u}_q+\cos(\phi t)$</p><ul><li>四元数变换<li><ul><li>用四元数表示旋转：</ul></ul><p>单位四元数可以以简单的方式表示任何三维旋转。</p><p>如图为单位四元数表示的旋转：</p><p><img data-proofer-ignore data-src="/assets/img/4-4.png" alt="" /></p><p>首先，把一个点或向量$\mathbf{p}=(p_x,p_y,p_z,p_w)^{T}$的四个坐标分别放进一个四元数$\hat{\mathbf{p}}$的各个分量中，假设我们有一个单位四元数$\hat{\mathbf{q}}=(\sin\phi\mathbf{u}_q,\cos\phi)$，可以证明：</p><p>$\hat{\mathbf{q}}\hat{\mathbf{p}}\hat{\mathbf{q}}^{-1}$</p><p>会使点$\hat{\mathbf{p}}$绕轴$\mathbf{u}_p$旋转$2\phi$弧度，如上图所示。注意因为$\hat{\mathbf{q}}$是单位四元数，则$\hat{\mathbf{q}}^{-1}=\hat{\mathbf{q}}^\ast$。</p><blockquote><p>注意：任何$\hat{\mathbf{q}}$的非零实数倍都和$\hat{\mathbf{q}}$表示相同的旋转变换。也就是说，$\hat{\mathbf{q}}$和$-\hat{\mathbf{q}}$表示的也是相同的旋转，这是因为我们同时对旋转轴$\mathbf{u}_p$和实部$q_w$取负。这也意味着从一个矩阵中提取的四元数可能是$\hat{\mathbf{q}}$或$-\hat{\mathbf{q}}$。</p></blockquote><ul><li><ul><li>两个四元数的连接：</ul></ul><p>给定两个四元数$\hat{\mathbf{q}}$和$\hat{\mathbf{r}}$（表示两个旋转变换），要实现它们的连接，即先进行$\hat{\mathbf{q}}$的变换，再进行$\hat{\mathbf{r}}$的变换，四元数点$\hat{\mathbf{p}}$是被旋转的对象，则对应的方程为：</p><p>$\hat{\mathbf{r}}(\hat{\mathbf{q}}\hat{\mathbf{p}}\hat{\mathbf{q}}^\ast)\hat{\mathbf{r}}^\ast=(\hat{\mathbf{r}}\hat{\mathbf{q}})\hat{\mathbf{p}}(\hat{\mathbf{r}}\hat{\mathbf{q}})^\ast=\hat{\mathbf{c}}\hat{\mathbf{p}}\hat{\mathbf{c}}^\ast$</p><p>这里的$\hat{\mathbf{c}}=\hat{\mathbf{r}}\hat{\mathbf{q}}$是单位四元数，表示两个四元数的连接，即两个旋转变换的连接。</p><ul><li><ul><li>矩阵和四元数的相互转换</ul></ul><p>很多时候我们需要结合多个变换，而它们中大部分是矩阵形式。我们需要一种方法把方程$\hat{\mathbf{q}}\hat{\mathbf{p}}\hat{\mathbf{q}}^{-1}$转换为矩阵。</p><p>一个四元数$\hat{\mathbf{q}}$可以被转换为一个矩阵$\mathbf{M}^q$：</p>\[\mathbf{M}^q=\left[\matrix{ 1-s(q_y^2+q_z^2) &amp; s(q_xq_y-q_wq_z) &amp; s(q_xq_z+q_wq_y) &amp; 0 \\ s(q_xq_y+q_wq_z) &amp; 1-s(q_x^2+q_z^2) &amp; s(q_yq_z-q_wq_x) &amp; 0 \\ s(q_xq_z-q_wq_y) &amp; s(q_yq_z+q_wq_x) &amp; 1-s(q_x^2+q_y^2) &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 }\right]\]<p>这里，$s=2/(n(\hat{\mathbf{q}}))^2$。对于单位四元数，上面方程可简化为：</p>\[\mathbf{M}^q=\left[\matrix{ 1-2(q_y^2+q_z^2) &amp; 2(q_xq_y-q_wq_z) &amp; 2(q_xq_z+q_wq_y) &amp; 0 \\ 2(q_xq_y+q_wq_z) &amp; 1-2(q_x^2+q_z^2) &amp; 2(q_yq_z-q_wq_x) &amp; 0 \\ 2(q_xq_z-q_wq_y) &amp; 2(q_yq_z+q_wq_x) &amp; 1-2(q_x^2+q_y^2) &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 }\right]\]<p>一旦构建好四元数，就不需要计算三角函数了。因此这个变换过程是很高效的。</p><p>把矩阵转换为四元数稍微复杂，且不太常用，此处不做记录。</p><ul><li>球面线性插值</ul><p>给定两个单位四元数$\hat{\mathbf{q}}$和$\hat{\mathbf{r}}$以及一个参数$t\in[0,1]$，插值得到一个新的四元数。</p><p>这个操作的代数形式被表达为一个复合四元数$\hat{\mathbf{s}}$：</p><p>$\hat{\mathbf{s}}(\hat{\mathbf{q}},\hat{\mathbf{r}},t)=(\hat{\mathbf{r}}\hat{\mathbf{q}}^{-1})^t\hat{\mathbf{q}}$</p><p>然而为了软件实现，下面的形式更合适：</p><p>$\hat{\mathbf{s}}(\hat{\mathbf{q}},\hat{\mathbf{r}},t)=slerp(\hat{\mathbf{q}},\hat{\mathbf{r}},t)=\frac{\sin(\phi(1-t))}{\sin\phi}\hat{\mathbf{q}}+\frac{\sin(\phi t)}{\sin\phi}\hat{\mathbf{r}}$</p><p>其中，$\cos\phi=q_xr_x+q_yr_y+q_zr_z+q_wr_w$</p><p>slerp函数插值得到的一系列四元数一起组成了一个四维单位球上从$\hat{\mathbf{q}}(t=0)$到$\hat{\mathbf{r}}(t=1)$的最短弧。这个最短弧位于一个圆上，而这个圆是由$\hat{\mathbf{q}}$，$\hat{\mathbf{r}}$以及原点组成的平面与这个四维单位球的交集构成。计算得到的旋转四元数绕固定的轴以恒定的速度旋转。</p><p>slerp函数非常适合在两个方向（orientatiosns）间进行插值，并且表现得很好(固定的轴，恒定的速度)。</p><p>当多于两个方向时，比如说由n个四元数\(\hat{\mathbf{q}}_0\)到\(\hat{\mathbf{q}}_{n-1}\)，我们想要从\(\hat{\mathbf{q}}_0\)插值到\(\hat{\mathbf{q}}_1\)，再插值到\(\hat{\mathbf{q}}_2\)，直到\(\hat{\mathbf{q}}_{n-1}\)，可以简单直接地使用slerp函数，但这样插值多点四元数会造成不连续的变化，如图所示：</p><p><img data-proofer-ignore data-src="/assets/img/4-5.png" alt="" /></p><p>可以看到$\hat{\mathbf{q}}_2$到$\hat{\mathbf{q}}_3$处有一个明显的拐角，得到了不够光滑的曲线。</p><p>一个更好的方法是使用样条曲线插值（spline）。在\(\hat{\mathbf{q}}_{i}\)和\(\hat{\mathbf{q}}_{i+1}\)之间引入\(\hat{\mathbf{a}}_i\)和\(\hat{\mathbf{a}}_{i+1}\)。球面三次插值可定义在\(\hat{\mathbf{q}}_i\)，\(\hat{\mathbf{a}}_i\)，\(\hat{\mathbf{a}}_{i+1}\)，\(\hat{\mathbf{q}}_{i+1}\)，上面。引入的这两个四元数可以这样计算：</p>\[\hat{\mathbf{a}}_i=\hat{\mathbf{q}}_i\exp\{-[\log(\hat{\mathbf{q}}_i^{-1}\hat{\mathbf{q}}_{i-1})+\log({\hat{\mathbf{q}}_i^{-1}\hat{\mathbf{q}}_{i+1}})]/4\}\] \[squad(\hat{\mathbf{q}}_i,\hat{\mathbf{q}}_{i+1},\hat{\mathbf{a}}_i,\hat{\mathbf{a}}_{i+1},t)=slerp(slerp(\hat{\mathbf{q}}_i,\hat{\mathbf{q}}_{i+1},t),slerp(\hat{\mathbf{a}}_i,\hat{\mathbf{a}}_{i+1},t),2t(1-t))\]<p>可以看到squad函数是由重复使用球形插值slerp得到的。</p><ul><li>从一个向量旋转到另一个向量</ul><p>从一个向量$\mathbf{s}$旋转到另一个向量$\mathbf{t}$也是一种常见的操作。四元数极大简化了这一过程。</p><p>首先我们把$\mathbf{s}$和$\mathbf{t}$归一化，然后计算单位旋转轴$\mathbf{u}=(\mathbf{s}\times\mathbf{t})/\vert\vert(\mathbf{s}\times\mathbf{t})\vert\vert$，然后$e=\mathbf{s}\cdot\mathbf{t}=\cos(2\phi)$，并且$\vert\vert(\mathbf{s}\times\mathbf{t})\vert\vert=\sin(2\phi)$，此处$2\phi$是$\mathbf{s}$和$\mathbf{t}$之间的夹角。则表示$\mathbf{s}$旋转到$\mathbf{t}$的四元数为：</p><p>$\hat{\mathbf{q}}=(\sin\phi \mathbf{u},\cos\phi)$</p><p>$=(\frac{1}{\sqrt{2(1+e)}}(\mathbf{s}\times\mathbf{t}),\frac{\sqrt{2(1+e)}}{2})$</p><p>但是，当$\mathbf{s}$和$\mathbf{t}$指向相反的方向时，上面的公式会有除以0的情况出现，即$e=\cos(2\phi)=-1$。当出现这种情况时，任意垂直于$\mathbf{s}$的旋转轴都可以用于旋转到$\mathbf{t}$。</p><p>有时我们也需要从$\mathbf{s}$旋转到$\mathbf{t}$的矩阵表示：</p>\[\mathbf{R}(\mathbf{s},\mathbf{t})=\left[\matrix{ e+hv_x^2 &amp; hv_xv_y-v_z &amp; hv_xv_z+v_y &amp; 0 \\ hv_xv_y+v_z &amp; e+hv_y^2 &amp; hv_yv_z-v_x &amp; 0 \\ hv_xv_z-v_y &amp; hv_yv_z+v_x &amp; e+hv_z^2 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 }\right]\]<p>其中，</p><p>$\mathbf{v}=\mathbf{s}\times\mathbf{t}$，</p><p>$e=\cos(2\phi)=\mathbf{s}\cdot\mathbf{t}$，</p><p>$h=\frac{1-\cos(2\phi)}{\sin^2(2\phi)}=\frac{1-e}{\mathbf{v}\cdot\mathbf{v}}=\frac{1}{1+e}$（当$\phi\neq0$且$\phi\neq\pi$时）。</p><p>当$\mathbf{s}$和$\mathbf{t}$平行或几乎平行时，因为$\vert\vert\mathbf{s}\times\mathbf{t}\vert\vert\approx 0$，所以无法计算$h$。如果$\phi\approx 0$，我们可以直接返回单位矩阵；而如果$\phi\approx\pi$，则绕任意轴旋转$\pi$弧度，这个轴可以通过求$\mathbf{s}$和任意不平行于$\mathbf{s}$的向量的叉积得到。</p><h3 id="投影projections">投影（Projections）</h3><p>在实际渲染场景之前，场景中的所有相关对象必须投影到某种平面或某种简单体积上。然后，执行裁剪和渲染。</p><p>我们前面的变换都没有影响第四个坐标，即w分量。也就是说，点和向量在变换后保留了它们的类型。而且，前面变换矩阵的最后一行都是（0 0 0 1）。</p><p>下面，我们假设观看者沿着摄像机的负$z$轴观看，$y$轴向上，$x$轴向右，即右手坐标系，这和Unity采用的方案。而DirectX使用左手坐标系，观察者沿相机的正$z$轴观看。这两种方法都是可行的，最终都能达到同样的效果。</p><ul><li>正交投影（Orthographic Projection）</ul><p>正交投影的一个特点是投影后平行线保持平行。当使用正交投影查看场景时，无论与摄影机的距离如何，对象都保持相同的大小。矩阵$\mathbf{P}_o$（如下所示）是一个简单的正交投影矩阵，它保持点的$x$和$y$分量不变，同时将$z$分量设置为零，即正交投影到平面$z=0$上：</p>\[\mathbf{P}_o=\left[\matrix{ 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 }\right]\]<p>该投影矩阵的效果如下图所示。很显然，$\mathbf{P}_o$是不可逆的，因为它的行列式$\vert\mathbf{P}_o\vert=0$。换句话说，这个变换把点从三维降到了二维，而且是不可逆的。使用这种正交投影的一个问题是，它将$z$值为正值的点和$z$值为负值的点都投影到了投影平面上。但是我们通常需要将$z$值（包括$x$值和$y$值）限制在一定的范围内，例如从$n$（近平面）到$f$（远平面）。</p><p><img data-proofer-ignore data-src="/assets/img/4-6.png" alt="" /></p><p>更为常用的正交投影矩阵由六元组$(l,r,b,t,n,f)$表示，表示左、右、下、上、近和远平面。该矩阵缩放并将这些平面形成的轴对齐边界框（AABB）转换为以原点为中心的轴对齐立方体。AABB的最小角为$(l,b,n)$，最大角为$(r,t,f)$。而且，我们需要$n&gt;f$，因为我们在这个空间中是沿着负$z$轴观看的。</p><p>在OpenGL中，轴对齐立方体的最小角为$(−1,−1,−1)$ 最大转角为$(1,1,1)$；在DirectX中，最小角为$(−1,−1,0)$ 最大转角为$(1,1,1)$。这个空间被称为规则观察体（canonical view volume），这个空间里的坐标被称为归一化的设备坐标（normalized device coordinates，简称为NDC）。转换为规则观察体是为了更方便地进行裁剪。</p><p>转换到规则观察体后，再根据该立方体剪裁要渲染的几何体的顶点，最后这些顶点再通过单位正方形映射到屏幕来进行渲染。此正交变换矩阵如下所示：</p>\[\mathbf{P}_o=\mathbf{S(\mathbf{s})\mathbf{T(\mathbf{t})}}= \left[\matrix{ \frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; \frac{2}{f-n} &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 }\right] \left[\matrix{ 1 &amp; 0 &amp; 0 &amp; -\frac{l+r}{2} \\ 0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2} \\ 0 &amp; 0 &amp; 1 &amp; -\frac{f+n}{2} \\ 0 &amp; 0 &amp; 0 &amp; 1 }\right]\] \[=\left[\matrix{ \frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\frac{r+l}{r-l} \\ 0 &amp; \frac{2}{t-b} &amp; 0 &amp; -\frac{t+b}{t-b} \\ 0 &amp; 0 &amp; \frac{2}{f-n} &amp; -\frac{f+n}{f-n} \\ 0 &amp; 0 &amp; 0 &amp; 1 }\right]\]<p>在计算机图形学中，投影后的空间通常为左手坐标系。因为我们定义AABB的远值小于近值，所以正交投影变换将会导致镜像变换。假设定义的AABB与规则观察体大小相同，即$(l,b,n)$对应$(-1,-1,1)$，$(r,t,f)$对应$(1,1,-1)$，那么正交投影矩阵将变成：</p>\[\mathbf{P}_o=\left[\matrix{ 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 }\right]\]<p>这是一个镜像矩阵，这会将右手观察坐标变换为左手标准化设备坐标。</p><p>DirectX将$z$深度映射到范围$[0,1]$，OpenGL为$[−1,1]$。 这可以通过在正交矩阵之后应用简单的缩放和平移矩阵来实现，即：</p>\[\mathbf{M}_{st}=\left[\matrix{ 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0.5 &amp; 0.5 \\ 0 &amp; 0 &amp; 0 &amp; 1 }\right]\]<p>所以，在DirectX中的正交投影矩阵为：</p>\[\mathbf{P}_{o[0,1]}=\left[\matrix{ \frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\frac{r+l}{r-l} \\ 0 &amp; \frac{2}{t-b} &amp; 0 &amp; -\frac{t+b}{t-b} \\ 0 &amp; 0 &amp; \frac{1}{f-n} &amp; -\frac{n}{f-n} \\ 0 &amp; 0 &amp; 0 &amp; 1 }\right]\]<ul><li>透视投影（Perspective Projection）</ul><p>透视投影比正交投影更复杂，它通常用于大多数计算机图形学应用中。透视投影后的平行线通常不平行；相反，它们可能在其极限处收敛到一个点。透视投影更接近于我们的人眼观看世界的感觉，也就是说，距离越远的物体越小。</p><p>首先，我们给定投影平面$z=-d,d&gt;0$，假设摄影机位于原点，并且我们希望将点$p$投影到平面$z=−d,d&gt;0$，产生一个新的点$q=(qx,qy,−d)$ 。该场景如图所示。从该图中所示的相似三角形中，我们可以得到$q$的$x$分量：</p><p>$\frac{q_x}{p_x}=\frac{-d}{p_z}\Leftrightarrow q_x=-d\frac{p_x}{p_z}$。</p><p><img data-proofer-ignore data-src="/assets/img/4-7.png" alt="" /></p><p>同样，我们也可以得到$q$的$y$分量：$q_y=-d\frac{p_y}{p_z}$。</p><p>因此我们可以得到透视投影矩阵$\mathbf{P}_p$：</p>\[\mathbf{P}_p=\left[\matrix{ 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; -1/d &amp; 0 }\right]\]<p>下面来看看这个矩阵的效果：</p>\[\mathbf{q}=\mathbf{P}_p\mathbf{p}=\left[\matrix{ 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; -1/d &amp; 0 }\right] \left[\matrix{p_x\\p_y\\p_z\\1}\right]=\left[\matrix{p_x\\p_y\\p_z\\-p_z/d}\right]\Rightarrow\left[\matrix{-dp_x/p_z\\-dp_y/p_z\\-d\\1}\right]\]<p>其中，最后一步是齐次除法（也叫透视除法），就是把齐次坐标的$x,y,z$分量分别除以$w$分量，因为我们始终约定将点$(p_x,p_y,p_z)$投影到平面$w=1$上。可以看到，变换后的点的$x,y,z$分量与我们上面计算到的结果相同。</p><p>和正交变换一样，还有一种透视变换是将视锥体（view frustum）转换为前面描述的规则观察体（canonical view volume）。我们假设视锥体从$z=n$开始，在$z=f$结束，$0&gt;n&gt;f$。$z=n$处的矩形在$(l,b,n)$处具有最小角点，在$(r,t,n)$处具有最大角点，如下图所示：</p><p><img data-proofer-ignore data-src="/assets/img/4-8.png" alt="" /></p><p>参数$(l,r,b,t,n,f)$确定摄像机的视锥体，$l,r$确定水平视野（horizontal field of view），$t,b$确定垂直视野（vertical field of view）。视野越大，摄像机观察到的越多。</p><p>视野（field of view，简称FOV）是提供场景感的一个重要因素。我们人眼本身就有一个视野。请看下面的式子：</p><p>$\phi=2\arctan(w/(2d))$</p><p>其中，$\phi$表示FOV，$w$表示垂直于摄像机视线的物体宽度，$d$表示物体到摄像机的距离。简单来说，$\phi$就是摄像机能够看到的左右两侧的角度。</p><p>设置更小的FOV会减少透视效果。设置更大的FOV会使物体看起来扭曲（例如广角相机镜头），特别是靠近屏幕边缘，并会夸大附近物体的比例。然而，更广阔的视野给观众一种物体更大、更令人印象深刻的感觉，并具有给用户更多关于周围环境的信息的优势。</p><p>将视锥体转换为单位立方体的透视变换矩阵如下所示：</p>\[\mathbf{P}_p=\left[\matrix{ \frac{2n}{r-l} &amp; 0 &amp; -\frac{r+l}{r-l} &amp; 0 \\ 0 &amp; \frac{2n}{t-b} &amp; -\frac{t+b}{t-b} &amp; 0 \\ 0 &amp; 0 &amp; \frac{f+n}{f-n} &amp; -\frac{2fn}{f-n} \\ 0 &amp; 0 &amp; 1 &amp; 0 }\right]\]<p>将这个变换应用到一个点后，我们将得到另一个点$\mathbf{q}=(q_x,q_y,q_z,q_w)^T$。其中$w$分量通常不为0或1。为了得到正确的投影点，我们还要进行齐次除法：$\mathbf{q}=(q_x/q_w,q_y/q_w,q_z/q_w,1)^T$</p><p>矩阵$\mathbf{P}_p$会将$z=f$的点映射到$+1$，$z=n$的点映射到$-1$。</p><p>远平面之外的物体将被裁剪，因此不会出现在场景中。但是透视投影也可以处理无限远的平面，我们只要将$f\rightarrow\infty$，此时矩阵变为：</p>\[\mathbf{P}_p=\left[\matrix{ \frac{2n}{r-l} &amp; 0 &amp; -\frac{r+l}{r-l} &amp; 0 \\ 0 &amp; \frac{2n}{t-b} &amp; -\frac{t+b}{t-b} &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; -2n \\ 0 &amp; 0 &amp; 1 &amp; 0 }\right]\]<p>总结：在应用透视变换矩阵$\mathbf{P}_p$后，再通过裁剪和齐次除法，我们就能得到归一化的设备坐标（NDC），</p><p>在上面的矩阵中，$n$和$f$值都为负数，但为了方便用户使用，我们通常还要将它们转换为正数，即$0&lt;n’&lt;f’$。</p><p>要得到OpenGL中的透视变换矩阵，我们还要进行一次镜像变换，即乘上$\mathbf{S}(1,1,-1,1)$，但实际上摄像机还是沿着负$z$轴观察，最后在OpenGL中的透视变换矩阵为：</p>\[\mathbf{P}_{OpenGL}=\left[\matrix{ \frac{2n'}{r-l} &amp; 0 &amp; \frac{r+l}{r-l} &amp; 0 \\ 0 &amp; \frac{2n'}{t-b} &amp; \frac{t+b}{t-b} &amp; 0 \\ 0 &amp; 0 &amp; -\frac{f'+n'}{f'-n'} &amp; -\frac{2f'n'}{f'-n'} \\ 0 &amp; 0 &amp; -1 &amp; 0 }\right]\]<p>但通常我们用一种更为简单的方式表达，即用户只需要提供垂直视野$\phi$（vertical field of view），宽高比$a=w/h$（aspect）（$w\times h$为屏幕分辨率），以及$n’$和$f’$。最终的透视变换矩阵为：</p>\[\mathbf{P}_{OpenGL}=\left[\matrix{ c/a &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; c &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -\frac{f'+n'}{f'-n'} &amp; -\frac{2f'n'}{f'-n'} \\ 0 &amp; 0 &amp; -1 &amp; 0 }\right]\]<p>其中，$c=1.0/\tan(\phi/2)$。这个矩阵就是旧版gluPerspective()中的矩阵，来源于OpenGL Utility Library（GLU）。</p><p>一些API（例如DirectX）把近平面映射到$z=0$（而不是$z=-1$），远平面映射到$z=1$。另外，DirectX使用左手坐标系作为观察坐标系，也就是说DirectX的摄像机从正$z$轴观察，并且$n$和$f$值都为正值，下面是DirectX中的透视变换矩阵：</p>\[\mathbf{P}_{p[0,1]}=\left[\matrix{ \frac{2n'}{r-l} &amp; 0 &amp; -\frac{r+l}{r-l} &amp; 0 \\ 0 &amp; \frac{2n'}{t-b} &amp; -\frac{t+b}{t-b} &amp; 0 \\ 0 &amp; 0 &amp; \frac{f'}{f'-n'} &amp; -\frac{f'n'}{f'-n'} \\ 0 &amp; 0 &amp; 1 &amp; 0 }\right]\]<p>另外，需要注意的是，使用透视变换矩阵后，计算后的深度值（depth value）不会随输入的$p_z$值成线性变化。如图所示：</p><p><img data-proofer-ignore data-src="/assets/img/4-9.png" alt="" /></p><p>我们很容易就可以推导出原因：</p><p>$z_{NDC}=\frac{d_{p_z}+e}{-p_z}=d-\frac{e}{p_z}$</p><p>其中，</p><p>$d=−(f′+n′)/(f′−n′)$，</p><p>$e=−2f′n′/(f′−n′)$。</p><p>我们可以发现，输出的深度值$z_{NDC}$和输入的深度值$p_z$是成反比的。</p><p>因此，近平面和远平面的位置会影响z-buffer​的精度，容易产生z-flighting。</p><p>有几种方法可以增加深度值的精度：</p><ul><li>reversed z，即存储$1.0-z_NDC$。<li>Kemen建议使用对数对每个顶点得深度值重新映射：</ul><p>$z=w(log_2(max(10^{-6},1+w))f_c-1)$，（OpenGL）</p><p>$z=w(log_2(max(10^{-6},1+w))f_c/2)$，（DirectX）</p><p>其中$w$是投影矩阵之后的顶点的w值，常数$f_c=2/log_2(f+1)$，其中$f$是远平面。</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/'>计算机</a>, <a href='/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/'>图形学</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>最近更新</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1-Percolator/">分布式数据库事务-Percolator</a><li><a href="/posts/RTR5/">Real-Time Rendering 第五章 着色基础（Shading Basics）</a><li><a href="/posts/RTR4/">Real-Time Rendering 第四章 变换（Transforms）</a><li><a href="/posts/RTR1/">Real-Time Rendering 第一章 介绍（Introduction）</a><li><a href="/posts/RTR2/">Real-Time Rendering 第二章 图形渲染流水线（The Graphics Rendering Pipeline）</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">文章内容</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/RTR1/"><div class="card-body"> <span class="timeago small" >2021-10-03<i class="unloaded">2021-10-03T14:07:43+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Real-Time Rendering 第一章 介绍（Introduction）</h3><div class="text-muted small"><p> Real-Time Rendering 第一章 介绍 实时渲染即在计算机上快速生成图像，它是计算机图形学中互动性最强的领域。屏幕上会出现一幅图像，观看者会采取行动或做出反应，这种反馈会影响下一步生成的内容。这种反应和渲染的循环速度非常快，以至于观众看不到单个图像，而是沉浸在动态过程中。 图像的显示速率以每秒帧数（FPS）或赫兹（Hz）为单位进行测量。以每秒一帧的速度，几乎没有交互性；用...</p></div></div></a></div><div class="card"> <a href="/posts/RTR2/"><div class="card-body"> <span class="timeago small" >2021-10-03<i class="unloaded">2021-10-03T14:07:43+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Real-Time Rendering 第二章 图形渲染流水线（The Graphics Rendering Pipeline）</h3><div class="text-muted small"><p> Real-Time Rendering 第二章 图形渲染流水线 这一章讲的是实时渲染的核心部分，即图形渲染流水线。图形渲染流水线的功能是通过给定的摄像机、三维物体信息、光源等信息，生成一个二维图像。因此，渲染流水线是实时渲染的底层工具。 在现实世界中，流水线概念以许多不同的形式表现出来，从工厂装配线到快餐厨房。它也适用于图形渲染。管道由几个阶段组成，每个阶段执行总任务的一部分。 流水...</p></div></div></a></div><div class="card"> <a href="/posts/RTR5/"><div class="card-body"> <span class="timeago small" >2021-10-07<i class="unloaded">2021-10-07T22:00:21+08:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Real-Time Rendering 第五章 着色基础（Shading Basics）</h3><div class="text-muted small"><p> Real-Time Rendering 第五章 着色基础 渲染三维对象的图像时，模型不仅应具有适当的几何形状，还应具有所需的视觉外观。根据不同的需求，模型的视觉外观可以是真实感外观（外观接近真实物体）或是各种风格化外观。如下图所示，上面的图片是一种真实感外观渲染，下面的图片是一种风格化外观渲染。 本章将讨论照片级真实感渲染和风格化渲染的着色基础。 着色模型（Shading Mod...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/RTR2/" class="btn btn-outline-primary" prompt="上一篇"><p>Real-Time Rendering 第二章 图形渲染流水线（The Graphics Rendering Pipeline）</p></a> <a href="/posts/RTR5/" class="btn btn-outline-primary" prompt="下一篇"><p>Real-Time Rendering 第五章 着色基础（Shading Basics）</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://github.com/VCisHere">VCisHere</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">热门标签</h4></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> <script> /* see: <https://docs.mathjax.org/en/latest/options/input/tex.html#tex-options> */ MathJax = { tex: { inlineMath: [ ['$', '$'], ['\\(', '\\)'] ], displayMath: [ ['$$', '$$'], ['\\[', '\\]'] ], processEscapes: true } }; </script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
